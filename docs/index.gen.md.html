                    <meta charset="utf-8">
                       **Sample API Doc**
                         1.1 Release


This is the markdeep generic "Company API" template.  Replace
`company-logo-512.png` with your organization's logo and adjust the
`company-api.css` styling to match the desired colors.

See `CA::OpenHandle()` for an example of an auto-generated API link.
The rest of the information on this page is bogus placeholder to show the formatting.


API Modules
====================================================================================

The CA library is a layer on top of the resource manager and parsing libraries that
provides utilities for streaming processing and client-side process construction.


ENUMS
====================================================================================


ClockDirection
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
enum ClockDirection {
	CLOCKWISE,
	COUNTERCLOCKWISE
};

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Orientation
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
enum Orientation {

	HORIZONTAL,
	VERTICAL
};

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

HAlign
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
enum HAlign {

	HALIGN_LEFT,
	HALIGN_CENTER,
	HALIGN_RIGHT
};

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

VAlign
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
enum VAlign {

	VALIGN_TOP,
	VALIGN_CENTER,
	VALIGN_BOTTOM
};

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Margin
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
enum Margin {

	MARGIN_LEFT,
	MARGIN_TOP,
	MARGIN_RIGHT,
	MARGIN_BOTTOM
};

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Side
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
enum Side {
	SIDE_LEFT,
	SIDE_TOP,
	SIDE_RIGHT,
	SIDE_BOTTOM
};

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Corner
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
enum Corner {

	CORNER_TOP_LEFT,
	CORNER_TOP_RIGHT,
	CORNER_BOTTOM_RIGHT,
	CORNER_BOTTOM_LEFT
};

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Error
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
enum Error {
	OK, 
	FAILED, 
	ERR_UNAVAILABLE, 
	ERR_UNCONFIGURED, 
	ERR_UNAUTHORIZED, 
	ERR_PARAMETER_RANGE_ERROR, 
	ERR_OUT_OF_MEMORY, 
	ERR_FILE_NOT_FOUND,
	ERR_FILE_BAD_DRIVE,
	ERR_FILE_BAD_PATH,
	ERR_FILE_NO_PERMISSION, 
	ERR_FILE_ALREADY_IN_USE,
	ERR_FILE_CANT_OPEN,
	ERR_FILE_CANT_WRITE,
	ERR_FILE_CANT_READ,
	ERR_FILE_UNRECOGNIZED, 
	ERR_FILE_CORRUPT,
	ERR_FILE_MISSING_DEPENDENCIES,
	ERR_FILE_EOF,
	ERR_CANT_OPEN, 
	ERR_CANT_CREATE, 
	ERR_QUERY_FAILED,
	ERR_ALREADY_IN_USE,
	ERR_LOCKED, 
	ERR_TIMEOUT,
	ERR_CANT_CONNECT, 
	ERR_CANT_RESOLVE,
	ERR_CONNECTION_ERROR,
	ERR_CANT_ACQUIRE_RESOURCE,
	ERR_CANT_FORK,
	ERR_INVALID_DATA, 
	ERR_INVALID_PARAMETER, 
	ERR_ALREADY_EXISTS, 
	ERR_DOES_NOT_EXIST, 
	ERR_DATABASE_CANT_READ, 
	ERR_DATABASE_CANT_WRITE, 
	ERR_COMPILATION_FAILED,
	ERR_METHOD_NOT_FOUND,
	ERR_LINK_FAILED,
	ERR_SCRIPT_FAILED,
	ERR_CYCLIC_LINK, 
	ERR_INVALID_DECLARATION,
	ERR_DUPLICATE_SYMBOL,
	ERR_PARSE_ERROR,
	ERR_BUSY,
	ERR_SKIP, 
	ERR_HELP, 
	ERR_BUG, 
	ERR_PRINTER_ON_FIRE, 
};

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
enum {

	POOL_ALLOCATOR_INVALID_ID = -1 
};

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
enum {
	KEYBOARD_SPKEY = (1 << 24)
};

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

KeyList
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
enum KeyList {
	
	KEY_ESCAPE = KEYBOARD_SPKEY | 0x01,
	KEY_TAB = KEYBOARD_SPKEY | 0x02,
	KEY_BACKTAB = KEYBOARD_SPKEY | 0x03,
	KEY_BACKSPACE = KEYBOARD_SPKEY | 0x04,
	KEY_ENTER = KEYBOARD_SPKEY | 0x05,
	KEY_KP_ENTER = KEYBOARD_SPKEY | 0x06,
	KEY_INSERT = KEYBOARD_SPKEY | 0x07,
	KEY_DELETE = KEYBOARD_SPKEY | 0x08,
	KEY_PAUSE = KEYBOARD_SPKEY | 0x09,
	KEY_PRINT = KEYBOARD_SPKEY | 0x0A,
	KEY_SYSREQ = KEYBOARD_SPKEY | 0x0B,
	KEY_CLEAR = KEYBOARD_SPKEY | 0x0C,
	KEY_HOME = KEYBOARD_SPKEY | 0x0D,
	KEY_END = KEYBOARD_SPKEY | 0x0E,
	KEY_LEFT = KEYBOARD_SPKEY | 0x0F,
	KEY_UP = KEYBOARD_SPKEY | 0x10,
	KEY_RIGHT = KEYBOARD_SPKEY | 0x11,
	KEY_DOWN = KEYBOARD_SPKEY | 0x12,
	KEY_PAGEUP = KEYBOARD_SPKEY | 0x13,
	KEY_PAGEDOWN = KEYBOARD_SPKEY | 0x14,
	KEY_SHIFT = KEYBOARD_SPKEY | 0x15,
	KEY_CONTROL = KEYBOARD_SPKEY | 0x16,
	KEY_META = KEYBOARD_SPKEY | 0x17,
	KEY_ALT = KEYBOARD_SPKEY | 0x18,
	KEY_CAPSLOCK = KEYBOARD_SPKEY | 0x19,
	KEY_NUMLOCK = KEYBOARD_SPKEY | 0x1A,
	KEY_SCROLLLOCK = KEYBOARD_SPKEY | 0x1B,
	KEY_F1 = KEYBOARD_SPKEY | 0x1C,
	KEY_F2 = KEYBOARD_SPKEY | 0x1D,
	KEY_F3 = KEYBOARD_SPKEY | 0x1E,
	KEY_F4 = KEYBOARD_SPKEY | 0x1F,
	KEY_F5 = KEYBOARD_SPKEY | 0x20,
	KEY_F6 = KEYBOARD_SPKEY | 0x21,
	KEY_F7 = KEYBOARD_SPKEY | 0x22,
	KEY_F8 = KEYBOARD_SPKEY | 0x23,
	KEY_F9 = KEYBOARD_SPKEY | 0x24,
	KEY_F10 = KEYBOARD_SPKEY | 0x25,
	KEY_F11 = KEYBOARD_SPKEY | 0x26,
	KEY_F12 = KEYBOARD_SPKEY | 0x27,
	KEY_F13 = KEYBOARD_SPKEY | 0x28,
	KEY_F14 = KEYBOARD_SPKEY | 0x29,
	KEY_F15 = KEYBOARD_SPKEY | 0x2A,
	KEY_F16 = KEYBOARD_SPKEY | 0x2B,
	KEY_KP_MULTIPLY = KEYBOARD_SPKEY | 0x81,
	KEY_KP_DIVIDE = KEYBOARD_SPKEY | 0x82,
	KEY_KP_SUBTRACT = KEYBOARD_SPKEY | 0x83,
	KEY_KP_PERIOD = KEYBOARD_SPKEY | 0x84,
	KEY_KP_ADD = KEYBOARD_SPKEY | 0x85,
	KEY_KP_0 = KEYBOARD_SPKEY | 0x86,
	KEY_KP_1 = KEYBOARD_SPKEY | 0x87,
	KEY_KP_2 = KEYBOARD_SPKEY | 0x88,
	KEY_KP_3 = KEYBOARD_SPKEY | 0x89,
	KEY_KP_4 = KEYBOARD_SPKEY | 0x8A,
	KEY_KP_5 = KEYBOARD_SPKEY | 0x8B,
	KEY_KP_6 = KEYBOARD_SPKEY | 0x8C,
	KEY_KP_7 = KEYBOARD_SPKEY | 0x8D,
	KEY_KP_8 = KEYBOARD_SPKEY | 0x8E,
	KEY_KP_9 = KEYBOARD_SPKEY | 0x8F,
	KEY_SUPER_L = KEYBOARD_SPKEY | 0x2C,
	KEY_SUPER_R = KEYBOARD_SPKEY | 0x2D,
	KEY_MENU = KEYBOARD_SPKEY | 0x2E,
	KEY_HYPER_L = KEYBOARD_SPKEY | 0x2F,
	KEY_HYPER_R = KEYBOARD_SPKEY | 0x30,
	KEY_HELP = KEYBOARD_SPKEY | 0x31,
	KEY_DIRECTION_L = KEYBOARD_SPKEY | 0x32,
	KEY_DIRECTION_R = KEYBOARD_SPKEY | 0x33,
	KEY_BACK = KEYBOARD_SPKEY | 0x40,
	KEY_FORWARD = KEYBOARD_SPKEY | 0x41,
	KEY_STOP = KEYBOARD_SPKEY | 0x42,
	KEY_REFRESH = KEYBOARD_SPKEY | 0x43,
	KEY_VOLUMEDOWN = KEYBOARD_SPKEY | 0x44,
	KEY_VOLUMEMUTE = KEYBOARD_SPKEY | 0x45,
	KEY_VOLUMEUP = KEYBOARD_SPKEY | 0x46,
	KEY_BASSBOOST = KEYBOARD_SPKEY | 0x47,
	KEY_BASSUP = KEYBOARD_SPKEY | 0x48,
	KEY_BASSDOWN = KEYBOARD_SPKEY | 0x49,
	KEY_TREBLEUP = KEYBOARD_SPKEY | 0x4A,
	KEY_TREBLEDOWN = KEYBOARD_SPKEY | 0x4B,
	KEY_MEDIAPLAY = KEYBOARD_SPKEY | 0x4C,
	KEY_MEDIASTOP = KEYBOARD_SPKEY | 0x4D,
	KEY_MEDIAPREVIOUS = KEYBOARD_SPKEY | 0x4E,
	KEY_MEDIANEXT = KEYBOARD_SPKEY | 0x4F,
	KEY_MEDIARECORD = KEYBOARD_SPKEY | 0x50,
	KEY_HOMEPAGE = KEYBOARD_SPKEY | 0x51,
	KEY_FAVORITES = KEYBOARD_SPKEY | 0x52,
	KEY_SEARCH = KEYBOARD_SPKEY | 0x53,
	KEY_STANDBY = KEYBOARD_SPKEY | 0x54,
	KEY_OPENURL = KEYBOARD_SPKEY | 0x55,
	KEY_LAUNCHMAIL = KEYBOARD_SPKEY | 0x56,
	KEY_LAUNCHMEDIA = KEYBOARD_SPKEY | 0x57,
	KEY_LAUNCH0 = KEYBOARD_SPKEY | 0x58,
	KEY_LAUNCH1 = KEYBOARD_SPKEY | 0x59,
	KEY_LAUNCH2 = KEYBOARD_SPKEY | 0x5A,
	KEY_LAUNCH3 = KEYBOARD_SPKEY | 0x5B,
	KEY_LAUNCH4 = KEYBOARD_SPKEY | 0x5C,
	KEY_LAUNCH5 = KEYBOARD_SPKEY | 0x5D,
	KEY_LAUNCH6 = KEYBOARD_SPKEY | 0x5E,
	KEY_LAUNCH7 = KEYBOARD_SPKEY | 0x5F,
	KEY_LAUNCH8 = KEYBOARD_SPKEY | 0x60,
	KEY_LAUNCH9 = KEYBOARD_SPKEY | 0x61,
	KEY_LAUNCHA = KEYBOARD_SPKEY | 0x62,
	KEY_LAUNCHB = KEYBOARD_SPKEY | 0x63,
	KEY_LAUNCHC = KEYBOARD_SPKEY | 0x64,
	KEY_LAUNCHD = KEYBOARD_SPKEY | 0x65,
	KEY_LAUNCHE = KEYBOARD_SPKEY | 0x66,
	KEY_LAUNCHF = KEYBOARD_SPKEY | 0x67,

	KEY_UNKNOWN = KEYBOARD_SPKEY | 0xFFFFFF,

	KEY_SPACE = 0x0020,
	KEY_EXCLAM = 0x0021,
	KEY_QUOTEDBL = 0x0022,
	KEY_NUMBERSIGN = 0x0023,
	KEY_DOLLAR = 0x0024,
	KEY_PERCENT = 0x0025,
	KEY_AMPERSAND = 0x0026,
	KEY_APOSTROPHE = 0x0027,
	KEY_PARENLEFT = 0x0028,
	KEY_PARENRIGHT = 0x0029,
	KEY_ASTERISK = 0x002A,
	KEY_PLUS = 0x002B,
	KEY_COMMA = 0x002C,
	KEY_MINUS = 0x002D,
	KEY_PERIOD = 0x002E,
	KEY_SLASH = 0x002F,
	KEY_0 = 0x0030,
	KEY_1 = 0x0031,
	KEY_2 = 0x0032,
	KEY_3 = 0x0033,
	KEY_4 = 0x0034,
	KEY_5 = 0x0035,
	KEY_6 = 0x0036,
	KEY_7 = 0x0037,
	KEY_8 = 0x0038,
	KEY_9 = 0x0039,
	KEY_COLON = 0x003A,
	KEY_SEMICOLON = 0x003B,
	KEY_LESS = 0x003C,
	KEY_EQUAL = 0x003D,
	KEY_GREATER = 0x003E,
	KEY_QUESTION = 0x003F,
	KEY_AT = 0x0040,
	KEY_A = 0x0041,
	KEY_B = 0x0042,
	KEY_C = 0x0043,
	KEY_D = 0x0044,
	KEY_E = 0x0045,
	KEY_F = 0x0046,
	KEY_G = 0x0047,
	KEY_H = 0x0048,
	KEY_I = 0x0049,
	KEY_J = 0x004A,
	KEY_K = 0x004B,
	KEY_L = 0x004C,
	KEY_M = 0x004D,
	KEY_N = 0x004E,
	KEY_O = 0x004F,
	KEY_P = 0x0050,
	KEY_Q = 0x0051,
	KEY_R = 0x0052,
	KEY_S = 0x0053,
	KEY_T = 0x0054,
	KEY_U = 0x0055,
	KEY_V = 0x0056,
	KEY_W = 0x0057,
	KEY_X = 0x0058,
	KEY_Y = 0x0059,
	KEY_Z = 0x005A,
	KEY_BRACKETLEFT = 0x005B,
	KEY_BACKSLASH = 0x005C,
	KEY_BRACKETRIGHT = 0x005D,
	KEY_ASCIICIRCUM = 0x005E,
	KEY_UNDERSCORE = 0x005F,
	KEY_QUOTELEFT = 0x0060,
	KEY_BRACELEFT = 0x007B,
	KEY_BAR = 0x007C,
	KEY_BRACERIGHT = 0x007D,
	KEY_ASCIITILDE = 0x007E,
	KEY_NOBREAKSPACE = 0x00A0,
	KEY_EXCLAMDOWN = 0x00A1,
	KEY_CENT = 0x00A2,
	KEY_STERLING = 0x00A3,
	KEY_CURRENCY = 0x00A4,
	KEY_YEN = 0x00A5,
	KEY_BROKENBAR = 0x00A6,
	KEY_SECTION = 0x00A7,
	KEY_DIAERESIS = 0x00A8,
	KEY_COPYRIGHT = 0x00A9,
	KEY_ORDFEMININE = 0x00AA,
	KEY_GUILLEMOTLEFT = 0x00AB,
	KEY_NOTSIGN = 0x00AC,
	KEY_HYPHEN = 0x00AD,
	KEY_REGISTERED = 0x00AE,
	KEY_MACRON = 0x00AF,
	KEY_DEGREE = 0x00B0,
	KEY_PLUSMINUS = 0x00B1,
	KEY_TWOSUPERIOR = 0x00B2,
	KEY_THREESUPERIOR = 0x00B3,
	KEY_ACUTE = 0x00B4,
	KEY_MU = 0x00B5,
	KEY_PARAGRAPH = 0x00B6,
	KEY_PERIODCENTERED = 0x00B7,
	KEY_CEDILLA = 0x00B8,
	KEY_ONESUPERIOR = 0x00B9,
	KEY_MASCULINE = 0x00BA,
	KEY_GUILLEMOTRIGHT = 0x00BB,
	KEY_ONEQUARTER = 0x00BC,
	KEY_ONEHALF = 0x00BD,
	KEY_THREEQUARTERS = 0x00BE,
	KEY_QUESTIONDOWN = 0x00BF,
	KEY_AGRAVE = 0x00C0,
	KEY_AACUTE = 0x00C1,
	KEY_ACIRCUMFLEX = 0x00C2,
	KEY_ATILDE = 0x00C3,
	KEY_ADIAERESIS = 0x00C4,
	KEY_ARING = 0x00C5,
	KEY_AE = 0x00C6,
	KEY_CCEDILLA = 0x00C7,
	KEY_EGRAVE = 0x00C8,
	KEY_EACUTE = 0x00C9,
	KEY_ECIRCUMFLEX = 0x00CA,
	KEY_EDIAERESIS = 0x00CB,
	KEY_IGRAVE = 0x00CC,
	KEY_IACUTE = 0x00CD,
	KEY_ICIRCUMFLEX = 0x00CE,
	KEY_IDIAERESIS = 0x00CF,
	KEY_ETH = 0x00D0,
	KEY_NTILDE = 0x00D1,
	KEY_OGRAVE = 0x00D2,
	KEY_OACUTE = 0x00D3,
	KEY_OCIRCUMFLEX = 0x00D4,
	KEY_OTILDE = 0x00D5,
	KEY_ODIAERESIS = 0x00D6,
	KEY_MULTIPLY = 0x00D7,
	KEY_OOBLIQUE = 0x00D8,
	KEY_UGRAVE = 0x00D9,
	KEY_UACUTE = 0x00DA,
	KEY_UCIRCUMFLEX = 0x00DB,
	KEY_UDIAERESIS = 0x00DC,
	KEY_YACUTE = 0x00DD,
	KEY_THORN = 0x00DE,
	KEY_SSHARP = 0x00DF,

	KEY_DIVISION = 0x00F7,
	KEY_YDIAERESIS = 0x00FF,

};

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

KeyModifierMask
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
enum KeyModifierMask {

	KEY_CODE_MASK = ((1 << 25) - 1), 
	KEY_MODIFIER_MASK = (0xFF << 24), 
	KEY_MASK_SHIFT = (1 << 25),
	KEY_MASK_ALT = (1 << 26),
	KEY_MASK_META = (1 << 27),
	KEY_MASK_CTRL = (1 << 28),
#ifdef APPLE_STYLE_KEYS
	KEY_MASK_CMD = KEY_MASK_META,
#else
	KEY_MASK_CMD = KEY_MASK_CTRL,
#endif

	KEY_MASK_KPAD = (1 << 29),
	KEY_MASK_GROUP_SWITCH = (1 << 30)
	
};

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ButtonList
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
enum ButtonList {
	BUTTON_LEFT = 1,
	BUTTON_RIGHT = 2,
	BUTTON_MIDDLE = 3,
	BUTTON_WHEEL_UP = 4,
	BUTTON_WHEEL_DOWN = 5,
	BUTTON_WHEEL_LEFT = 6,
	BUTTON_WHEEL_RIGHT = 7,
	BUTTON_XBUTTON1 = 8,
	BUTTON_XBUTTON2 = 9,
	BUTTON_MASK_LEFT = (1 << (BUTTON_LEFT - 1)),
	BUTTON_MASK_RIGHT = (1 << (BUTTON_RIGHT - 1)),
	BUTTON_MASK_MIDDLE = (1 << (BUTTON_MIDDLE - 1)),
	BUTTON_MASK_XBUTTON1 = (1 << (BUTTON_XBUTTON1 - 1)),
	BUTTON_MASK_XBUTTON2 = (1 << (BUTTON_XBUTTON2 - 1))
};

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


STRUCTS
====================================================================================


Comparator
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct Comparator {
	_ALWAYS_INLINE_ bool operator();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

_GlobalLock
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct _GlobalLock {
	_GlobalLock();
	~_GlobalLock();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

_GlobalNil
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct _GlobalNil {
	int color;
	_GlobalNil *right;
	_GlobalNil *left;
	_GlobalNil *parent;

	_GlobalNil();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

_GlobalNilClass
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct _GlobalNilClass {
	static _GlobalNil _nil;
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

_DefaultComparator
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct _DefaultComparator {
	bool operator();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

CharRange
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct CharRange {
	char32_t start;
	char32_t end;
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

StrRange
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct StrRange {
	const CharType *c_str;
	int len;

	StrRange(const CharType *p_c_str = nullptr, int p_len = 0);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

NoCaseComparator
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct NoCaseComparator {
	bool operator();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

NaturalNoCaseComparator
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct NaturalNoCaseComparator {
	bool operator();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

StaticCString
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct StaticCString {
	const char *ptr;
	static StaticCString create(const char *p_ptr);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

MemoryPool
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct MemoryPool {
	
	static PoolAllocator *memory_pool;
	static uint8_t *pool_memory;
	static size_t *pool_size;

	struct Alloc {
		SafeRefCount refcount;
		SafeNumeric<uint32_t> lock;
		void *mem;
		PoolAllocator::ID pool_id;
		size_t size;

		Alloc *free_list;

		Alloc();
	};

	static Alloc *allocs;
	static Alloc *free_list;
	static uint32_t alloc_count;
	static uint32_t allocs_used;
	static Mutex alloc_mutex;
	static size_t total_memory;
	static size_t max_memory;

	static void setup(uint32_t p_max_allocs = (1 << 16);
	static void cleanup();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Color
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct Color {
	union {
		struct {
			float r;
			float g;
			float b;
			float a;
		};
		float components[4];
	};

	bool operator==(const Color &p_color);
	bool operator!=(const Color &p_color);

	uint32_t to_rgba32();
	uint32_t to_argb32();
	uint32_t to_abgr32();
	uint64_t to_rgba64();
	uint64_t to_argb64();
	uint64_t to_abgr64();
	float get_h();
	float get_s();
	float get_v();
	void set_hsv(float p_h, float p_s, float p_v, float p_alpha = 1.0);

	float &operator[](int idx);
	const float &operator[](int idx);

	Color operator+(const Color &p_color);
	void operator+=(const Color &p_color);

	Color operator-();
	Color operator-(const Color &p_color);
	void operator-=(const Color &p_color);

	Color operator*(const Color &p_color);
	Color operator*(const real_t &rvalue);
	void operator*=(const Color &p_color);
	void operator*=(const real_t &rvalue);

	Color operator/(const Color &p_color);
	Color operator/(const real_t &rvalue);
	void operator/=(const Color &p_color);
	void operator/=(const real_t &rvalue);

	bool is_equal_approx(const Color &p_color);

	Color clamp(const Color &p_min = Color(0, 0, 0, 0);

	void invert();
	void contrast();
	Color inverted();
	Color contrasted();

	float get_luminance();

	Color linear_interpolate(const Color &p_to, float p_weight);

	Color darkened(float p_amount);

	Color lightened(float p_amount);

	uint32_t to_rgbe9995();

	Color blend(const Color &p_over);

	Color to_linear();
	Color to_srgb();

	static Color hex(uint32_t p_hex);
	static Color hex64(uint64_t p_hex);
	static Color html(const String &p_color);
	static bool html_is_valid(const String &p_color);
	String to_html(bool p_alpha = true);
	Color from_hsv(float p_h, float p_s, float p_v, float p_a);
	static Color from_rgbe9995(uint32_t p_rgbe);

	bool operator<(const Color &p_color);
	operator String();

	static Color color8(int r, int g, int b);

	static Color color8(int r, int g, int b, int a);

	void set_r8(int32_t r8);
	int32_t get_r8();
	void set_g8(int32_t g8);
	int32_t get_g8();
	void set_b8(int32_t b8);
	int32_t get_b8();
	void set_a8(int32_t a8);
	int32_t get_a8();

	void set_h(float p_h);
	void set_s(float p_s);
	void set_v(float p_v);

	Color();

	Color(float p_r, float p_g, float p_b, float p_a = 1.0);

	Color(const Color &p_c, float p_a);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Vector2
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct Vector2 {
	static const int AXIS_COUNT = 2;

	enum Axis {
		AXIS_X,
		AXIS_Y,
	};

	union {
		struct {
			union {
				real_t x;
				real_t width;
			};
			union {
				real_t y;
				real_t height;
			};
		};

		real_t coord[2];
	};

	real_t &operator[](int p_idx);
	const real_t &operator[](int p_idx);

	void set_all(real_t p_value);

	int min_axis();

	int max_axis();

	void normalize();
	Vector2 normalized();
	bool is_normalized();

	real_t length();
	real_t length_squared();
	Vector2 limit_length(const real_t p_len = 1.0);

	Vector2 min(const Vector2 &p_vector2);

	Vector2 max(const Vector2 &p_vector2);

	real_t distance_to(const Vector2 &p_vector2);
	real_t distance_squared_to(const Vector2 &p_vector2);
	real_t angle_to(const Vector2 &p_vector2);
	real_t angle_to_point(const Vector2 &p_vector2);
	Vector2 direction_to(const Vector2 &p_to);

	real_t dot(const Vector2 &p_other);
	real_t cross(const Vector2 &p_other);
	Vector2 posmod(const real_t p_mod);
	Vector2 posmodv(const Vector2 &p_modv);
	Vector2 project(const Vector2 &p_to);

	Vector2 plane_project(real_t p_d, const Vector2 &p_vec);

	static Vector2 linear_interpolate(const Vector2 &p_a, const Vector2 &p_b, real_t p_weight);
	Vector2 linear_interpolate(const Vector2 &p_to, real_t p_weight);
	Vector2 slerp(const Vector2 &p_to, real_t p_weight);
	Vector2 cubic_interpolate(const Vector2 &p_b, const Vector2 &p_pre_a, const Vector2 &p_post_b, real_t p_weight);
	Vector2 bezier_interpolate(const Vector2 &p_control_1, const Vector2 &p_control_2, const Vector2 &p_end, const real_t p_t);

	Vector2 move_toward(const Vector2 &p_to, const real_t p_delta);

	Vector2 slide(const Vector2 &p_normal);
	Vector2 bounce(const Vector2 &p_normal);
	Vector2 reflect(const Vector2 &p_normal);

	bool is_equal_approx(const Vector2 &p_v);

	Vector2 operator+(const Vector2 &p_v);
	void operator+=(const Vector2 &p_v);
	Vector2 operator-(const Vector2 &p_v);
	void operator-=(const Vector2 &p_v);
	Vector2 operator*(const Vector2 &p_v1);

	Vector2 operator*(const real_t &rvalue);
	void operator*=(const real_t &rvalue);
	void operator*=(const Vector2 &rvalue);

	Vector2 operator/(const Vector2 &p_v1);

	Vector2 operator/(const real_t &rvalue);

	void operator/=(const real_t &rvalue);
	void operator/=(const Vector2 &rvalue);

	Vector2 operator-();

	bool operator==(const Vector2 &p_vec2);
	bool operator!=(const Vector2 &p_vec2);

	bool operator<(const Vector2 &p_vec2);
	bool operator>(const Vector2 &p_vec2);
	bool operator<=(const Vector2 &p_vec2);
	bool operator>=(const Vector2 &p_vec2);

	real_t angle();

	void set_rotation(real_t p_radians);

	Vector2 abs();

	Vector2 rotated(real_t p_by);
	Vector2 tangent();
	Vector2 orthogonal();

	Vector2 sign();
	Vector2 floor();
	Vector2 ceil();
	Vector2 round();
	Vector2 snapped(const Vector2 &p_by);
	real_t aspect();

	operator String();

	Vector2(real_t p_x, real_t p_y);
	Vector2();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Vector2i
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct Vector2i {
	enum Axis {
		AXIS_X,
		AXIS_Y,
	};

	union {
		struct {
			union {
				int x;
				int width;
			};
			union {
				int y;
				int height;
			};
		};

		int coord[2];
	};

	int &operator[](int p_idx);
	const int &operator[](int p_idx);

	void set_all(int p_value);

	int min_axis();

	int max_axis();

	Vector2i min(const Vector2i &p_vector2i);

	Vector2i max(const Vector2i &p_vector2i);

	static Vector2i linear_interpolate(const Vector2i &p_a, const Vector2i &p_b, real_t p_weight);
	Vector2i linear_interpolate(const Vector2i &p_to, real_t p_weight);

	Vector2i operator+(const Vector2i &p_v);
	void operator+=(const Vector2i &p_v);
	Vector2i operator-(const Vector2i &p_v);
	void operator-=(const Vector2i &p_v);
	Vector2i operator*(const Vector2i &p_v1);

	Vector2i operator*(const int &rvalue);
	void operator*=(const int &rvalue);

	Vector2i operator/(const Vector2i &p_v1);

	Vector2i operator/(const int &rvalue);

	void operator/=(const int &rvalue);

	Vector2i operator-();
	bool operator<(const Vector2i &p_vec2);
	bool operator>(const Vector2i &p_vec2);
	bool operator<=(const Vector2 &p_vec2);
	bool operator>=(const Vector2 &p_vec2);

	bool operator==(const Vector2i &p_vec2);
	bool operator!=(const Vector2i &p_vec2);

	int64_t length_squared();
	double length();

	real_t aspect();
	Vector2i sign();
	Vector2i abs();
	Vector2i clamp(const Vector2i &p_min, const Vector2i &p_max);

	Vector2 to_vector2();

	operator String();
	operator Vector2();

	Vector2i(const Vector2 &p_vec2);
	Vector2i(int p_x, int p_y);
	Vector2i();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Rect2
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct Rect2 {
	Point2 position;
	Size2 size;

	const Vector2 &get_position();
	void set_position(const Vector2 &p_pos);
	const Vector2 &get_size();
	void set_size(const Vector2 &p_size);

	real_t get_area();

	Vector2 get_center();

	bool intersects(const Rect2 &p_rect, const bool p_include_borders = false);

	real_t distance_to(const Vector2 &p_point);

	bool intersects_transformed(const Transform2D &p_xform, const Rect2 &p_rect);

	bool intersects_segment(const Point2 &p_from, const Point2 &p_to, Point2 *r_pos = nullptr, Point2 *r_normal = nullptr);

	bool encloses(const Rect2 &p_rect);

	bool has_no_area();
	Rect2 clip(const Rect2 &p_rect);

	Rect2 intersection(const Rect2 &p_rect);

	Rect2 merge(const Rect2 &p_rect);
	bool has_point(const Point2 &p_point);
	bool is_equal_approx(const Rect2 &p_rect);

	bool operator==(const Rect2 &p_rect);
	bool operator!=(const Rect2 &p_rect);

	Rect2 grow(real_t p_by);

	void grow_by(real_t p_by);

	Rect2 grow_margin(Margin p_margin, real_t p_amount);

	Rect2 grow_side(Side p_side, real_t p_amount);

	Rect2 grow_individual(real_t p_left, real_t p_top, real_t p_right, real_t p_bottom);

	Rect2 expand(const Vector2 &p_vector);

	void expand_to(const Vector2 &p_vector);

	Rect2 abs();

	Vector2 get_support(const Vector2 &p_normal);

	bool intersects_filled_polygon(const Vector2 *p_points, int p_point_count);

	void set_end(const Vector2 &p_end);

	Vector2 get_end();

	operator String();

	Rect2();
	Rect2(real_t p_x, real_t p_y, real_t p_width, real_t p_height);
	Rect2(const Point2 &p_pos, const Size2 &p_size);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Rect2i
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct Rect2i {
	Point2i position;
	Size2i size;

	const Point2i &get_position();
	void set_position(const Point2i &p_position);
	const Size2i &get_size();
	void set_size(const Size2i &p_size);

	int get_area();

	Vector2i get_center();

	bool intersects(const Rect2i &p_rect);

	bool encloses(const Rect2i &p_rect);

	bool has_no_area();

	Rect2i clip(const Rect2i &p_rect);

	Rect2i intersection(const Rect2i &p_rect);

	Rect2i merge(const Rect2i &p_rect);

	bool has_point(const Point2i &p_point);

	bool operator==(const Rect2i &p_rect);
	bool operator!=(const Rect2i &p_rect);

	Rect2i grow(int p_by);

	void grow_by(int p_by);

	Rect2i grow_margin(Margin p_margin, int p_amount);

	Rect2i grow_side(Side p_side, int p_amount);

	Rect2i grow_individual(int p_left, int p_top, int p_right, int p_bottom);

	Rect2i expand(const Vector2i &p_vector);

	void expand_to(const Point2i &p_vector);

	Rect2i abs();

	void set_end(const Vector2i &p_end);

	Vector2i get_end();

	Rect2 to_rect2();

	operator String();
	operator Rect2();

	Rect2i(const Rect2 &p_r2);
	Rect2i();
	Rect2i(int p_x, int p_y, int p_width, int p_height);
	Rect2i(const Point2 &p_pos, const Size2 &p_size);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Vector3
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct Vector3 {
	static const int AXIS_COUNT = 3;

	enum Axis {
		AXIS_X,
		AXIS_Y,
		AXIS_Z,
	};

	union {
		struct {
			real_t x;
			real_t y;
			real_t z;
		};

		real_t coord[3];
	};

	const real_t &operator[](int p_axis);

	real_t &operator[](int p_axis);

	void set_axis(int p_axis, real_t p_value);
	real_t get_axis(int p_axis);

	void set_all(real_t p_value);

	int min_axis();

	int max_axis();

	real_t length();
	real_t length_squared();

	void normalize();
	Vector3 normalized();
	bool is_normalized();
	Vector3 inverse();
	Vector3 limit_length(const real_t p_len = 1.0);

	void zero();

	void snap(const Vector3 &p_val);
	Vector3 snapped(const Vector3 &p_val);

	void rotate(const Vector3 &p_axis, real_t p_phi);
	Vector3 rotated(const Vector3 &p_axis, real_t p_phi);

	Vector3 linear_interpolate(const Vector3 &p_to, real_t p_weight);
	Vector3 slerp(const Vector3 &p_to, real_t p_weight);
	Vector3 cubic_interpolate(const Vector3 &p_b, const Vector3 &p_pre_a, const Vector3 &p_post_b, real_t p_weight);
	Vector3 bezier_interpolate(const Vector3 &p_control_1, const Vector3 &p_control_2, const Vector3 &p_end, const real_t p_t);

	Vector3 move_toward(const Vector3 &p_to, const real_t p_delta);

	Vector3 cross(const Vector3 &p_b);
	real_t dot(const Vector3 &p_b);
	Basis outer(const Vector3 &p_b);
	Basis to_diagonal_matrix();

	Vector3 abs();
	Vector3 floor();
	Vector3 sign();
	Vector3 ceil();
	Vector3 round();
	Vector3 clamp(const Vector3 &p_min, const Vector3 &p_max);

	real_t distance_to(const Vector3 &p_to);
	real_t distance_squared_to(const Vector3 &p_to);

	Vector3 posmod(const real_t p_mod);
	Vector3 posmodv(const Vector3 &p_modv);
	Vector3 project(const Vector3 &p_to);

	real_t angle_to(const Vector3 &p_to);
	real_t signed_angle_to(const Vector3 &p_to, const Vector3 &p_axis);
	Vector3 direction_to(const Vector3 &p_to);

	Vector3 slide(const Vector3 &p_normal);
	Vector3 bounce(const Vector3 &p_normal);
	Vector3 reflect(const Vector3 &p_normal);

	bool is_equal_approx(const Vector3 &p_v);
	bool is_equal_approx(const Vector3 &p_v, real_t p_tolerance);
	bool is_equal_approxt(const Vector3 &p_v, real_t p_tolerance);

	Vector3 &operator+=(const Vector3 &p_v);
	Vector3 operator+(const Vector3 &p_v);
	Vector3 &operator-=(const Vector3 &p_v);
	Vector3 operator-(const Vector3 &p_v);
	Vector3 &operator*=(const Vector3 &p_v);
	Vector3 operator*(const Vector3 &p_v);
	Vector3 &operator/=(const Vector3 &p_v);
	Vector3 operator/(const Vector3 &p_v);

	Vector3 &operator*=(real_t p_scalar);
	Vector3 operator*(real_t p_scalar);
	Vector3 &operator/=(real_t p_scalar);
	Vector3 operator/(real_t p_scalar);

	Vector3 operator-();

	bool operator==(const Vector3 &p_v);
	bool operator!=(const Vector3 &p_v);
	bool operator<(const Vector3 &p_v);
	bool operator<=(const Vector3 &p_v);
	bool operator>(const Vector3 &p_v);
	bool operator>=(const Vector3 &p_v);

	operator String();

	Vector3(real_t p_x, real_t p_y, real_t p_z);
	Vector3();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Vector3i
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct Vector3i {
	enum Axis {
		AXIS_X,
		AXIS_Y,
		AXIS_Z,
	};

	union {
		struct {
			int32_t x;
			int32_t y;
			int32_t z;
		};

		int32_t coord[3];
	};

	const int32_t &operator[](const int p_axis);

	int32_t &operator[](const int p_axis);

	void set_axis(const int p_axis, const int32_t p_value);
	int32_t get_axis(const int p_axis);

	void set_all(int32_t p_value);

	Vector3i::Axis min_axis();
	Vector3i::Axis max_axis();

	int64_t length_squared();
	double length();

	void zero();

	Vector3i abs();
	Vector3i sign();
	Vector3i clamp(const Vector3i &p_min, const Vector3i &p_max);

	Vector3i linear_interpolate(const Vector3i &p_to, real_t p_weight);

	Vector3i &operator+=(const Vector3i &p_v);
	Vector3i operator+(const Vector3i &p_v);
	Vector3i &operator-=(const Vector3i &p_v);
	Vector3i operator-(const Vector3i &p_v);
	Vector3i &operator*=(const Vector3i &p_v);
	Vector3i operator*(const Vector3i &p_v);
	Vector3i &operator/=(const Vector3i &p_v);
	Vector3i operator/(const Vector3i &p_v);
	Vector3i &operator%=(const Vector3i &p_v);
	Vector3i operator%(const Vector3i &p_v);

	Vector3i &operator*=(const int32_t p_scalar);
	Vector3i operator*(const int32_t p_scalar);
	Vector3i &operator/=(const int32_t p_scalar);
	Vector3i operator/(const int32_t p_scalar);
	Vector3i &operator%=(const int32_t p_scalar);
	Vector3i operator%(const int32_t p_scalar);

	Vector3i operator-();

	bool operator==(const Vector3i &p_v);
	bool operator!=(const Vector3i &p_v);
	bool operator<(const Vector3i &p_v);
	bool operator<=(const Vector3i &p_v);
	bool operator>(const Vector3i &p_v);
	bool operator>=(const Vector3i &p_v);

	Vector3 to_vector3();

	operator String();
	operator Vector3();

	Vector3i();
	Vector3i(const int32_t p_x, const int32_t p_y, const int32_t p_z);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Vector4
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct Vector4 {
	enum Axis {
		AXIS_X,
		AXIS_Y,
		AXIS_Z,
		AXIS_W,
	};

	union {
		struct {
			real_t x;
			real_t y;
			real_t z;
			real_t w;
		};
		real_t components[4];
	};

	real_t &operator[](const int p_axis);
	const real_t &operator[](const int p_axis);

	void set_all(const real_t p_value);

	void set_axis(const int p_axis, const real_t p_value);
	real_t get_axis(const int p_axis);

	Vector4::Axis min_axis();
	Vector4::Axis max_axis();

	real_t length_squared();
	bool is_equal_approx(const Vector4 &p_vec4);
	real_t length();
	void normalize();
	Vector4 normalized();
	bool is_normalized();
	Vector4 limit_length(const real_t p_len = 1.0);

	void zero();

	real_t distance_to(const Vector4 &p_to);
	real_t distance_squared_to(const Vector4 &p_to);
	Vector4 direction_to(const Vector4 &p_to);

	Vector4 abs();
	Vector4 sign();
	Vector4 floor();
	Vector4 ceil();
	Vector4 round();

	Vector4 linear_interpolate(const Vector4 &p_to, const real_t p_weight);
	Vector4 cubic_interpolate(const Vector4 &p_b, const Vector4 &p_pre_a, const Vector4 &p_post_b, const real_t p_weight);

	Vector4 posmod(const real_t p_mod);
	Vector4 posmodv(const Vector4 &p_modv);
	void snap(const Vector4 &p_step);
	Vector4 snapped(const Vector4 &p_step);
	Vector4 clamp(const Vector4 &p_min, const Vector4 &p_max);

	Vector4 inverse();
	real_t dot(const Vector4 &p_vec4);

	void operator+=(const Vector4 &p_vec4);
	void operator-=(const Vector4 &p_vec4);
	void operator*=(const Vector4 &p_vec4);
	void operator/=(const Vector4 &p_vec4);
	void operator*=(const real_t &s);
	void operator/=(const real_t &s);
	Vector4 operator+(const Vector4 &p_vec4);
	Vector4 operator-(const Vector4 &p_vec4);
	Vector4 operator*(const Vector4 &p_vec4);
	Vector4 operator/(const Vector4 &p_vec4);
	Vector4 operator-();
	Vector4 operator*(const real_t &s);
	Vector4 operator/(const real_t &s);

	bool operator==(const Vector4 &p_vec4);
	bool operator!=(const Vector4 &p_vec4);
	bool operator>(const Vector4 &p_vec4);
	bool operator<(const Vector4 &p_vec4);
	bool operator>=(const Vector4 &p_vec4);
	bool operator<=(const Vector4 &p_vec4);

	operator String();

	Vector4();

	Vector4(real_t p_x, real_t p_y, real_t p_z, real_t p_w);

	Vector4(const Vector4 &p_vec4);

	void operator=(const Vector4 &p_vec4);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Vector4i
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct Vector4i {
	enum Axis {
		AXIS_X,
		AXIS_Y,
		AXIS_Z,
		AXIS_W,
	};

	union {
		struct {
			int32_t x;
			int32_t y;
			int32_t z;
			int32_t w;
		};

		int32_t coord[4];
	};

	const int32_t &operator[](const int p_axis);

	int32_t &operator[](const int p_axis);

	void set_all(const int32_t p_value);

	void set_axis(const int p_axis, const int32_t p_value);
	int32_t get_axis(const int p_axis);

	Vector4i::Axis min_axis();
	Vector4i::Axis max_axis();

	int64_t length_squared();
	double length();

	void zero();

	Vector4i abs();
	Vector4i sign();
	Vector4i clamp(const Vector4i &p_min, const Vector4i &p_max);

	Vector4i linear_interpolate(const Vector4i &p_to, const real_t p_weight);

	Vector4i &operator+=(const Vector4i &p_v);
	Vector4i operator+(const Vector4i &p_v);
	Vector4i &operator-=(const Vector4i &p_v);
	Vector4i operator-(const Vector4i &p_v);
	Vector4i &operator*=(const Vector4i &p_v);
	Vector4i operator*(const Vector4i &p_v);
	Vector4i &operator/=(const Vector4i &p_v);
	Vector4i operator/(const Vector4i &p_v);
	Vector4i &operator%=(const Vector4i &p_v);
	Vector4i operator%(const Vector4i &p_v);

	Vector4i &operator*=(const int32_t p_scalar);
	Vector4i operator*(const int32_t p_scalar);
	Vector4i &operator/=(const int32_t p_scalar);
	Vector4i operator/(const int32_t p_scalar);
	Vector4i &operator%=(const int32_t p_scalar);
	Vector4i operator%(const int32_t p_scalar);

	Vector4i operator-();

	bool operator==(const Vector4i &p_v);
	bool operator!=(const Vector4i &p_v);
	bool operator<(const Vector4i &p_v);
	bool operator<=(const Vector4i &p_v);
	bool operator>(const Vector4i &p_v);
	bool operator>=(const Vector4i &p_v);

	Vector4 to_vector4();

	operator String();
	operator Vector4();

	Vector4i();

	Vector4i(const int32_t p_x, const int32_t p_y, const int32_t p_z, const int32_t p_w);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Plane
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct Plane {
	Vector3 normal;
	real_t d;

	void set_normal(const Vector3 &p_normal);
	Vector3 get_normal();

	void normalize();
	Plane normalized();

	Vector3 center();
	Vector3 get_any_point();
	Vector3 get_any_perpendicular_normal();

	bool is_point_over(const Vector3 &p_point);
	real_t distance_to(const Vector3 &p_point);
	bool has_point(const Vector3 &p_point, real_t _epsilon = CMP_EPSILON);

	bool intersect_3(const Plane &p_plane1, const Plane &p_plane2, Vector3 *r_result = nullptr);
	bool intersects_ray(const Vector3 &p_from, const Vector3 &p_dir, Vector3 *p_intersection);
	bool intersects_segment(const Vector3 &p_begin, const Vector3 &p_end, Vector3 *p_intersection);

	Vector3 project(const Vector3 &p_point);

	Plane operator-();
	bool is_equal_approx(const Plane &p_plane);
	bool is_equal_approx_any_side(const Plane &p_plane);

	bool operator==(const Plane &p_plane);
	bool operator!=(const Plane &p_plane);
	operator String();

	Plane();
	Plane(real_t p_a, real_t p_b, real_t p_c, real_t p_d);

	Plane(const Vector3 &p_normal, real_t p_d);
	Plane(const Vector3 &p_point, const Vector3 &p_normal);
	Plane(const Vector3 &p_point1, const Vector3 &p_point2, const Vector3 &p_point3, ClockDirection p_dir = CLOCKWISE);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

AABB
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct AABB {
	Vector3 position;
	Vector3 size;

	real_t get_volume();
	bool has_no_volume();

	bool has_no_surface();

	const Vector3 &get_position();
	void set_position(const Vector3 &p_pos);
	const Vector3 &get_size();
	void set_size(const Vector3 &p_size);

	bool operator==(const AABB &p_rval);
	bool operator!=(const AABB &p_rval);

	bool is_equal_approx(const AABB &p_aabb);
	bool intersects(const AABB &p_aabb);
	bool intersects_inclusive(const AABB &p_aabb);
	bool encloses(const AABB &p_aabb);

	AABB merge(const AABB &p_with);
	void merge_with(const AABB &p_aabb);
	AABB intersection(const AABB &p_aabb);
	bool intersects_segment(const Vector3 &p_from, const Vector3 &p_to, Vector3 *r_clip = nullptr, Vector3 *r_normal = nullptr);
	bool intersects_ray(const Vector3 &p_from, const Vector3 &p_dir, Vector3 *r_clip = nullptr, Vector3 *r_normal = nullptr);
	bool smits_intersect_ray(const Vector3 &p_from, const Vector3 &p_dir, real_t t0, real_t t1);

	bool intersects_convex_shape(const Plane *p_planes, int p_plane_count, const Vector3 *p_points, int p_point_count);
	bool inside_convex_shape(const Plane *p_planes, int p_plane_count);
	bool intersects_plane(const Plane &p_plane);

	bool has_point(const Vector3 &p_point);
	Vector3 get_support(const Vector3 &p_normal);

	Vector3 get_longest_axis();
	int get_longest_axis_index();
	real_t get_longest_axis_size();

	Vector3 get_shortest_axis();
	int get_shortest_axis_index();
	real_t get_shortest_axis_size();

	AABB grow(real_t p_by);
	void grow_by(real_t p_amount);

	void get_edge(int p_edge, Vector3 &r_from, Vector3 &r_to);
	Vector3 get_endpoint(int p_point);

	AABB expand(const Vector3 &p_vector);
	void project_range_in_plane(const Plane &p_plane, real_t &r_min, real_t &r_max);
	void expand_to(const Vector3 &p_vector);
	bool create_from_points(const Vector<Vector3> &p_points);

	AABB abs();

	void quantize(real_t p_unit);
	AABB quantized(real_t p_unit);

	void set_end(const Vector3 &p_end);

	Vector3 get_end();

	Vector3 get_center();

	operator String();

	AABB();
	AABB(const Vector3 &p_pos, const Vector3 &p_size);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Quaternion
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct Quaternion {
	union {
		struct {
			real_t x;
			real_t y;
			real_t z;
			real_t w;
		};
		real_t components[4];
	};

	real_t &operator[](int idx);
	const real_t &operator[](int idx);

	real_t length_squared();
	bool is_equal_approx(const Quaternion &p_quat);
	real_t length();
	void normalize();
	Quaternion normalized();
	bool is_normalized();
	Quaternion inverse();
	Quaternion log();
	Quaternion exp();
	real_t dot(const Quaternion &p_q);
	real_t angle_to(const Quaternion &p_to);

	void set_euler_xyz(const Vector3 &p_euler);
	Vector3 get_euler_xyz();
	void set_euler_yxz(const Vector3 &p_euler);
	Vector3 get_euler_yxz();

	void set_euler(const Vector3 &p_euler);
	Vector3 get_euler();

	Quaternion slerp(const Quaternion &p_to, const real_t &p_weight);
	Quaternion slerpni(const Quaternion &p_to, const real_t &p_weight);
	Quaternion cubic_slerp(const Quaternion &p_b, const Quaternion &p_pre_a, const Quaternion &p_post_b, const real_t &p_weight);
	Quaternion spherical_cubic_interpolate(const Quaternion &p_b, const Quaternion &p_pre_a, const Quaternion &p_post_b, const real_t &p_weight);

	Vector3 get_axis();
	float get_angle();

	void set_axis_angle(const Vector3 &axis, const real_t &angle);
	void get_axis_angle(Vector3 &r_axis, real_t &r_angle);

	void operator*=(const Quaternion &p_q);
	Quaternion operator*(const Quaternion &p_q);

	Quaternion operator*(const Vector3 &v);

	Vector3 xform(const Vector3 &v);

	void operator+=(const Quaternion &p_q);
	void operator-=(const Quaternion &p_q);
	void operator*=(const real_t &s);
	void operator/=(const real_t &s);
	Quaternion operator+(const Quaternion &q2);
	Quaternion operator-(const Quaternion &q2);
	Quaternion operator-();
	Quaternion operator*(const real_t &s);
	Quaternion operator/(const real_t &s);

	bool operator==(const Quaternion &p_quat);
	bool operator!=(const Quaternion &p_quat);

	operator String();

	void set(real_t p_x, real_t p_y, real_t p_z, real_t p_w);
	Quaternion(real_t p_x, real_t p_y, real_t p_z, real_t p_w);
	Quaternion(const Vector3 &axis, const real_t &angle);

	Quaternion(const Vector3 &euler);
	Quaternion(const Quaternion &p_q);

	Quaternion &operator=(const Quaternion &p_q);

	Quaternion(const Vector3 &v0, const Vector3 &v1);

	Quaternion();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Projection
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct Projection {
	enum Planes {
		PLANE_NEAR,
		PLANE_FAR,
		PLANE_LEFT,
		PLANE_TOP,
		PLANE_RIGHT,
		PLANE_BOTTOM
	};

	Vector4 matrix[4];

	const Vector4 &operator[](const int p_axis);

	Vector4 &operator[](const int p_axis);

	float determinant();
	void set_identity();
	void set_zero();
	void set_light_bias();
	void set_depth_correction(bool p_flip_y = true);

	void set_light_atlas_rect(const Rect2 &p_rect);
	void set_perspective(real_t p_fovy_degrees, real_t p_aspect, real_t p_z_near, real_t p_z_far, bool p_flip_fov = false);
	void set_perspective(real_t p_fovy_degrees, real_t p_aspect, real_t p_z_near, real_t p_z_far, bool p_flip_fov, int p_eye, real_t p_intraocular_dist, real_t p_convergence_dist);
	void set_for_hmd(int p_eye, real_t p_aspect, real_t p_intraocular_dist, real_t p_display_width, real_t p_display_to_lens, real_t p_oversample, real_t p_z_near, real_t p_z_far);
	void set_orthogonal(real_t p_left, real_t p_right, real_t p_bottom, real_t p_top, real_t p_znear, real_t p_zfar);
	void set_orthogonal(real_t p_size, real_t p_aspect, real_t p_znear, real_t p_zfar, bool p_flip_fov = false);
	void set_frustum(real_t p_left, real_t p_right, real_t p_bottom, real_t p_top, real_t p_near, real_t p_far);
	void set_frustum(real_t p_size, real_t p_aspect, Vector2 p_offset, real_t p_near, real_t p_far, bool p_flip_fov = false);
	void adjust_perspective_znear(real_t p_new_znear);

	static Projection create_depth_correction(bool p_flip_y);
	static Projection create_light_atlas_rect(const Rect2 &p_rect);
	static Projection create_perspective(real_t p_fovy_degrees, real_t p_aspect, real_t p_z_near, real_t p_z_far, bool p_flip_fov = false);
	static Projection create_perspective_hmd(real_t p_fovy_degrees, real_t p_aspect, real_t p_z_near, real_t p_z_far, bool p_flip_fov, int p_eye, real_t p_intraocular_dist, real_t p_convergence_dist);
	static Projection create_for_hmd(int p_eye, real_t p_aspect, real_t p_intraocular_dist, real_t p_display_width, real_t p_display_to_lens, real_t p_oversample, real_t p_z_near, real_t p_z_far);
	static Projection create_orthogonal(real_t p_left, real_t p_right, real_t p_bottom, real_t p_top, real_t p_znear, real_t p_zfar);
	static Projection create_orthogonal_aspect(real_t p_size, real_t p_aspect, real_t p_znear, real_t p_zfar, bool p_flip_fov = false);
	static Projection create_frustum(real_t p_left, real_t p_right, real_t p_bottom, real_t p_top, real_t p_near, real_t p_far);
	static Projection create_frustum_aspect(real_t p_size, real_t p_aspect, Vector2 p_offset, real_t p_near, real_t p_far, bool p_flip_fov = false);
	static Projection create_fit_aabb(const AABB &p_aabb);

	Projection perspective_znear_adjusted(real_t p_new_znear);
	Plane get_projection_plane(Planes p_plane);
	Projection flipped_y();
	Projection jitter_offseted(const Vector2 &p_offset);

	static real_t get_fovy(real_t p_fovx, real_t p_aspect);

	real_t calculate_fovy(real_t p_fovx, real_t p_aspect);

	real_t get_z_far();
	real_t get_z_near();
	real_t get_aspect();
	real_t get_fov();
	bool is_orthogonal();

	Vector<Plane> get_projection_planes(const Transform &p_transform);

	bool get_endpoints(const Transform &p_transform, Vector3 *p_8points);
	Vector2 get_viewport_half_extents();
	Vector2 get_far_plane_half_extents();

	void invert();
	Projection inverse();

	Projection operator*(const Projection &p_matrix);

	Vector4 xform(const Vector4 &p_vec4);
	Vector4 xform_inv(const Vector4 &p_vec4);

	Vector3 xform(const Vector3 &p_vector);
	Plane xform(const Plane &p_plane);

	operator String();

	void scale_translate_to_fit(const AABB &p_aabb);
	void add_jitter_offset(const Vector2 &p_offset);
	void make_scale(const Vector3 &p_scale);
	int get_pixels_per_meter(int p_for_pixel_width);
	operator Transform();

	void flip_y();

	bool operator==(const Projection &p_cam);

	bool operator!=(const Projection &p_cam);

	float get_lod_multiplier();

	void set_perspective1(real_t p_fovy_degrees, real_t p_aspect, real_t p_z_near, real_t p_z_far, bool p_flip_fov = false);
	void set_perspective2(real_t p_fovy_degrees, real_t p_aspect, real_t p_z_near, real_t p_z_far, bool p_flip_fov, int p_eye, real_t p_intraocular_dist, real_t p_convergence_dist);
	void set_orthogonal1(real_t p_left, real_t p_right, real_t p_bottom, real_t p_top, real_t p_znear, real_t p_zfar);
	void set_orthogonal2(real_t p_size, real_t p_aspect, real_t p_znear, real_t p_zfar, bool p_flip_fov = false);
	void set_frustum1(real_t p_left, real_t p_right, real_t p_bottom, real_t p_top, real_t p_near, real_t p_far);
	
	void set_frustum2(real_t p_size, real_t p_aspect, Vector2 p_offset, real_t p_near, real_t p_far, bool p_flip_fov = false);

	Projection();
	Projection(const Vector4 &p_x, const Vector4 &p_y, const Vector4 &p_z, const Vector4 &p_w);
	Projection(const Transform &p_transform);
	~Projection();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Basis
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct Basis {
	Vector3 rows[3] = {
		Vector3(1, 0, 0);
	}
	Vector3 &operator[](int p_row);

	void invert();
	void transpose();

	Basis inverse();
	Basis transposed();

	real_t determinant();

	void from_z(const Vector3 &p_z);

	void rotate(const Vector3 &p_axis, real_t p_phi);
	Basis rotated(const Vector3 &p_axis, real_t p_phi);

	void rotate_local(const Vector3 &p_axis, real_t p_phi);
	Basis rotated_local(const Vector3 &p_axis, real_t p_phi);

	void rotate(const Vector3 &p_euler);
	Basis rotated(const Vector3 &p_euler);

	void rotate(const Quaternion &p_quat);
	Basis rotated(const Quaternion &p_quat);

	void rotatev(const Vector3 &p_euler);
	Basis rotatedv(const Vector3 &p_euler);
	void rotateq(const Quaternion &p_quat);
	Basis rotatedq(const Quaternion &p_quat);

	Vector3 get_rotation_euler();
	void get_rotation_axis_angle(Vector3 &p_axis, real_t &p_angle);
	void get_rotation_axis_angle_local(Vector3 &p_axis, real_t &p_angle);
	Quaternion get_rotation_quaternion();
	Vector3 get_rotation();

	void rotate_to_align(const Vector3 &p_start_direction, const Vector3 &p_end_direction);

	Vector3 rotref_posscale_decomposition(Basis &rotref);

	Vector3 get_euler_xyz();
	void set_euler_xyz(const Vector3 &p_euler);

	Vector3 get_euler_xzy();
	void set_euler_xzy(const Vector3 &p_euler);

	Vector3 get_euler_yzx();
	void set_euler_yzx(const Vector3 &p_euler);

	Vector3 get_euler_yxz();
	void set_euler_yxz(const Vector3 &p_euler);

	Vector3 get_euler_zxy();
	void set_euler_zxy(const Vector3 &p_euler);

	Vector3 get_euler_zyx();
	void set_euler_zyx(const Vector3 &p_euler);

	Vector3 get_euler();
	void set_euler(const Vector3 &p_euler);

	Quaternion get_quaternion();
	void set_quaternion(const Quaternion &p_quat);

	void get_axis_angle(Vector3 &r_axis, real_t &r_angle);
	void set_axis_angle(const Vector3 &p_axis, real_t p_phi);

	void scale(const Vector3 &p_scale);
	Basis scaled(const Vector3 &p_scale);

	void scale_local(const Vector3 &p_scale);
	Basis scaled_local(const Vector3 &p_scale);

	void scale_orthogonal(const Vector3 &p_scale);
	Basis scaled_orthogonal(const Vector3 &p_scale);

	void make_scale_uniform();
	real_t get_uniform_scale();

	Vector3 get_scale();
	Vector3 get_scale_abs();
	Vector3 get_scale_local();

	void set_axis_angle_scale(const Vector3 &p_axis, real_t p_phi, const Vector3 &p_scale);
	void set_euler_scale(const Vector3 &p_euler, const Vector3 &p_scale);
	void set_quaternion_scale(const Quaternion &p_quat, const Vector3 &p_scale);

	real_t tdotx(const Vector3 &v);
	real_t tdoty(const Vector3 &v);
	real_t tdotz(const Vector3 &v);

	bool is_equal_approx(const Basis &p_basis);
	bool is_equal_approx_ratio(const Basis &a, const Basis &b, real_t p_epsilon = UNIT_EPSILON);

	bool operator==(const Basis &p_matrix);
	bool operator!=(const Basis &p_matrix);

	Vector3 xform(const Vector3 &p_vector);
	Vector3 xform_inv(const Vector3 &p_vector);

	Vector3i xform(const Vector3i &p_vector);
	Vector3i xform_inv(const Vector3i &p_vector);

	void operator*=(const Basis &p_matrix);
	Basis operator*(const Basis &p_matrix);
	void operator+=(const Basis &p_matrix);
	Basis operator+(const Basis &p_matrix);
	void operator-=(const Basis &p_matrix);
	Basis operator-(const Basis &p_matrix);
	void operator*=(real_t p_val);
	Basis operator*(real_t p_val);

	int get_orthogonal_index();
	void set_orthogonal_index(int p_index);

	void set_diagonal(const Vector3 &p_diag);

	bool is_orthogonal();
	bool is_diagonal();
	bool is_rotation();

	Basis slerp(const Basis &p_to, const real_t &p_weight);
	Basis lerp(const Basis &p_to, const real_t &p_weight);
	void rotate_sh(real_t *p_values);

	operator String();

	void set(real_t xx, real_t xy, real_t xz, real_t yx, real_t yy, real_t yz, real_t zx, real_t zy, real_t zz);
	void set(const Vector3 &p_x, const Vector3 &p_y, const Vector3 &p_z);

	Vector3 get_column(int i);

	void set_column(int p_index, const Vector3 &p_value);

	void set_columns(const Vector3 &p_x, const Vector3 &p_y, const Vector3 &p_z);

	Vector3 get_row(int i);
	void set_row(int i, const Vector3 &p_row);

	Vector3 get_axis(int i);

	void set_axis(int p_index, const Vector3 &p_value);

	Vector3 get_main_diagonal();

	void set_zero();

	Basis transpose_xform(const Basis &m);
	Basis(real_t xx, real_t xy, real_t xz, real_t yx, real_t yy, real_t yz, real_t zx, real_t zy, real_t zz);

	void orthonormalize();
	Basis orthonormalized();

	void orthogonalize();
	Basis orthogonalized();

	bool is_symmetric();
	Basis diagonalize();

	Basis get_normal_xform_basis();

	Vector3 xform_normal_fast(const Vector3 &p_vector);

	Vector3 xform_normal(const Vector3 &p_vector);

	static Basis looking_at(const Vector3 &p_target, const Vector3 &p_up = Vector3(0, 1, 0);
	static Basis from_scale(const Vector3 &p_scale);

	operator Quaternion();

	Basis(const Quaternion &p_quat);
	Basis(const Quaternion &p_quat, const Vector3 &p_scale);

	Basis(const Vector3 &p_euler);
	Basis(const Vector3 &p_euler, const Vector3 &p_scale);

	Basis(const Vector3 &p_axis, real_t p_phi);
	Basis(const Vector3 &p_axis, real_t p_phi, const Vector3 &p_scale);

	Basis(const Vector3 &row0, const Vector3 &row1, const Vector3 &row2);

	Basis();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Transform2D
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct Transform2D {
	
	Vector2 columns[3];

	real_t tdotx(const Vector2 &v);
	real_t tdoty(const Vector2 &v);

	const Vector2 &operator[](int p_idx);
	Vector2 &operator[](int p_idx);

	Vector2 get_axis(int p_axis);
	void set_axis(int p_axis, const Vector2 &p_vec);

	Vector2 get_column(int p_colum);
	void set_column(int p_colum, const Vector2 &p_vec);

	void invert();
	Transform2D inverse();

	void affine_invert();
	Transform2D affine_inverse();

	void set_rotation(real_t p_rot);
	real_t get_rotation();
	real_t get_skew();
	void set_skew(const real_t p_angle);
	void set_rotation_and_scale(real_t p_rot, const Size2 &p_scale);
	void set_rotation_scale_and_skew(const real_t p_rot, const Size2 &p_scale, const real_t p_skew);
	void rotate(real_t p_phi);

	void scale(const Size2 &p_scale);
	void scale_basis(const Size2 &p_scale);
	void translate(real_t p_tx, real_t p_ty);
	void translate(const Vector2 &p_offset);
	void translate_local(real_t p_tx, real_t p_ty);
	void translate_local(const Vector2 &p_translation);

	void translater(real_t p_tx, real_t p_ty);
	void translatev(const Vector2 &p_offset);
	void translate_localr(real_t p_tx, real_t p_ty);
	void translate_localv(const Vector2 &p_translation);

	real_t basis_determinant();

	Size2 get_scale();
	void set_scale(const Size2 &p_scale);

	const Vector2 &get_origin();
	void set_origin(const Vector2 &p_origin);

	Transform2D basis_scaled(const Size2 &p_scale);
	Transform2D scaled(const Size2 &p_scale);
	Transform2D scaled_local(const Size2 &p_scale);
	Transform2D translated(const Vector2 &p_offset);
	Transform2D translated_local(const Vector2 &p_offset);
	Transform2D rotated(const real_t p_angle);
	Transform2D rotated_local(const real_t p_angle);

	Transform2D untranslated();

	void orthonormalize();
	Transform2D orthonormalized();
	bool is_equal_approx(const Transform2D &p_transform);

	Transform2D looking_at(const Vector2 &p_target);

	bool operator==(const Transform2D &p_transform);
	bool operator!=(const Transform2D &p_transform);

	void operator*=(const Transform2D &p_transform);
	Transform2D operator*(const Transform2D &p_transform);
	void operator*=(const real_t p_val);
	Transform2D operator*(const real_t p_val);

	Transform2D interpolate_with(const Transform2D &p_transform, real_t p_c);

	Vector2 basis_xform(const Vector2 &p_vec);
	Vector2 basis_xform_inv(const Vector2 &p_vec);
	Vector2 xform(const Vector2 &p_vec);
	Vector2 xform_inv(const Vector2 &p_vec);

	Rect2 xform(const Rect2 &p_rect);
	Rect2 xform_inv(const Rect2 &p_rect);

	Vector2i basis_xform(const Vector2i &p_vec);
	Vector2i basis_xform_inv(const Vector2i &p_vec);
	Vector2i xform(const Vector2i &p_vec);
	Vector2i xform_inv(const Vector2i &p_vec);

	PoolVector<Vector2> xform(const PoolVector<Vector2> &p_array);
	PoolVector<Vector2> xform_inv(const PoolVector<Vector2> &p_array);
	PoolVector<Vector2i> xform(const PoolVector<Vector2i> &p_array);
	PoolVector<Vector2i> xform_inv(const PoolVector<Vector2i> &p_array);

	operator String();

	Transform2D(real_t xx, real_t xy, real_t yx, real_t yy, real_t ox, real_t oy);

	Transform2D(const Vector2 &p_x, const Vector2 &p_y, const Vector2 &p_origin);

	Transform2D(real_t p_rot, const Vector2 &p_pos);

	Transform2D(const real_t p_rot, const Size2 &p_scale, const real_t p_skew, const Vector2 &p_pos);

	Transform2D();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Face3
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct Face3 {
	enum Side {
		SIDE_OVER,
		SIDE_UNDER,
		SIDE_SPANNING,
		SIDE_COPLANAR
	};

	Vector3 vertex[3];

	int split_by_plane(const Plane &p_plane, Face3 *p_res, bool *p_is_point_over);

	Plane get_plane(ClockDirection p_dir = CLOCKWISE);
	Vector3 get_random_point_inside();

	Side get_side_of(const Face3 &p_face, ClockDirection p_clock_dir = CLOCKWISE);

	bool is_degenerate();
	real_t get_area();
	real_t get_twice_area_squared();

	Vector3 get_median_point();
	Vector3 get_closest_point_to(const Vector3 &p_point);

	bool intersects_ray(const Vector3 &p_from, const Vector3 &p_dir, Vector3 *p_intersection = nullptr);
	bool intersects_segment(const Vector3 &p_from, const Vector3 &p_dir, Vector3 *p_intersection = nullptr);

	ClockDirection get_clock_dir();

	void get_support(const Vector3 &p_normal, const Transform &p_transform, Vector3 *p_vertices, int *p_count, int p_max);
	void project_range(const Vector3 &p_normal, const Transform &p_transform, real_t &r_min, real_t &r_max);

	AABB get_aabb();

	bool intersects_aabb(const AABB &p_aabb);
	bool intersects_aabb2(const AABB &p_aabb);
	operator String();

	Face3();
	Face3(const Vector3 &p_v1, const Vector3 &p_v2, const Vector3 &p_v3);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Transform
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct Transform {
	Basis basis;
	Vector3 origin;

	void invert();
	Transform inverse();

	void affine_invert();
	Transform affine_inverse();

	Transform rotated(const Vector3 &p_axis, real_t p_phi);
	Transform rotated_local(const Vector3 &p_axis, real_t p_phi);

	void rotate(const Vector3 &p_axis, real_t p_phi);
	void rotate_local(const Vector3 &p_axis, real_t p_phi);
	void rotate_basis(const Vector3 &p_axis, real_t p_phi);

	void set_look_at(const Vector3 &p_eye, const Vector3 &p_target, const Vector3 &p_up);
	Transform looking_at(const Vector3 &p_target, const Vector3 &p_up);

	void scale(const Vector3 &p_scale);
	Transform scaled(const Vector3 &p_scale);
	Transform scaled_local(const Vector3 &p_scale);
	void scale_basis(const Vector3 &p_scale);

	void translate_local(real_t p_tx, real_t p_ty, real_t p_tz);
	void translate_local(const Vector3 &p_translation);
	void translate_localr(real_t p_tx, real_t p_ty, real_t p_tz);
	void translate_localv(const Vector3 &p_translation);
	Transform translated(const Vector3 &p_translation);
	Transform translated_local(const Vector3 &p_translation);

	const Basis &get_basis();
	void set_basis(const Basis &p_basis);

	const Vector3 &get_origin();
	void set_origin(const Vector3 &p_origin);

	void orthonormalize();
	Transform orthonormalized();
	void orthogonalize();
	Transform orthogonalized();
	bool is_equal_approx(const Transform &p_transform);

	bool operator==(const Transform &p_transform);
	bool operator!=(const Transform &p_transform);

	Vector3 xform(const Vector3 &p_vector);
	Vector3i xform(const Vector3i &p_vector);
	AABB xform(const AABB &p_aabb);
	PoolVector<Vector3> xform(const PoolVector<Vector3> &p_array);
	PoolVector<Vector3i> xform(const PoolVector<Vector3i> &p_array);

	Vector3 xform_inv(const Vector3 &p_vector);
	Vector3i xform_inv(const Vector3i &p_vector);
	AABB xform_inv(const AABB &p_aabb);
	PoolVector<Vector3> xform_inv(const PoolVector<Vector3> &p_array);
	PoolVector<Vector3i> xform_inv(const PoolVector<Vector3i> &p_array);

	Plane xform(const Plane &p_plane);
	Plane xform_inv(const Plane &p_plane);

	Plane xform_fast(const Plane &p_plane, const Basis &p_basis_inverse_transpose);
	static Plane xform_inv_fast(const Plane &p_plane, const Transform &p_inverse, const Basis &p_basis_transpose);

	void operator*=(const Transform &p_transform);
	Transform operator*(const Transform &p_transform);
	void operator*=(const real_t p_val);
	Transform operator*(const real_t p_val);

	Transform spherical_interpolate_with(const Transform &p_transform, real_t p_c);
	Transform interpolate_with(const Transform &p_transform, real_t p_c);

	Transform inverse_xform(const Transform &t);

	void set(real_t xx, real_t xy, real_t xz, real_t yx, real_t yy, real_t yz, real_t zx, real_t zy, real_t zz, real_t tx, real_t ty, real_t tz);

	operator String();

	Transform(real_t xx, real_t xy, real_t xz, real_t yx, real_t yy, real_t yz, real_t zx, real_t zy, real_t zz, real_t ox, real_t oy, real_t oz);
	Transform(const Basis &p_basis, const Vector3 &p_origin = Vector3();
	Transform(const Vector3 &p_x, const Vector3 &p_y, const Vector3 &p_z, const Vector3 &p_origin);
	Transform();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

HashMapHasherDefault
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct HashMapHasherDefault {
	
	template <class T>
	static uint32_t hash(const T *p_pointer);

	template <class T>
	static uint32_t hash(const Ref<T> &p_ref);

	static uint32_t hash(const String &p_string);
	static uint32_t hash(const char *p_cstr);
	static uint32_t hash(const wchar_t p_wchar);
	static uint32_t hash(const char16_t p_uchar);
	static uint32_t hash(const char32_t p_uchar);
	static uint32_t hash(const StringName &p_string_name);

	static uint32_t hash(const uint64_t p_int);
	static uint32_t hash(const int64_t p_int);
	static uint32_t hash(const float p_float);
	static uint32_t hash(const double p_double);
	static uint32_t hash(const uint32_t p_int);
	static uint32_t hash(const int32_t p_int);
	static uint32_t hash(const uint16_t p_int);
	static uint32_t hash(const int16_t p_int);
	static uint32_t hash(const uint8_t p_int);
	static uint32_t hash(const int8_t p_int);

	static uint32_t hash(const Vector2i &p_vec);
	static uint32_t hash(const Vector3i &p_vec);
	static uint32_t hash(const Vector4i &p_vec);
	static uint32_t hash(const Vector2 &p_vec);
	static uint32_t hash(const Vector3 &p_vec);
	static uint32_t hash(const Vector4 &p_vec);
	static uint32_t hash(const Rect2i &p_rect);
	static uint32_t hash(const Rect2 &p_rect);
	static uint32_t hash(const AABB &p_aabb);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

HashMapComparatorDefault
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct HashMapComparatorDefault {
	static bool compare(const T &p_lhs, const T &p_rhs);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

HashMapComparatorDefault<float>
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct HashMapComparatorDefault<float> {
	static bool compare(const float &p_lhs, const float &p_rhs);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

HashMapComparatorDefault<double>
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct HashMapComparatorDefault<double> {
	static bool compare(const double &p_lhs, const double &p_rhs);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

HashMapComparatorDefault<Vector2>
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct HashMapComparatorDefault<Vector2> {
	static bool compare(const Vector2 &p_lhs, const Vector2 &p_rhs);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

HashMapComparatorDefault<Vector3>
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct HashMapComparatorDefault<Vector3> {
	static bool compare(const Vector3 &p_lhs, const Vector3 &p_rhs);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Pair
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct Pair {
	F first;
	S second;

	Pair();

	Pair(F p_first, const S &p_second);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

PairSort
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct PairSort {
	bool operator();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

PairHash
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct PairHash {
	static uint32_t hash(const Pair<F, S> &P);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

KeyValue
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct KeyValue {
	const K key;
	V value;

	void operator=(const KeyValue &p_kv);
	KeyValue(const KeyValue &p_kv);
	KeyValue(const K &p_key, const V &p_value);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

KeyValueSort
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct KeyValueSort {
	bool operator();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

VariantHasher
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct VariantHasher {
	static uint32_t hash(const Variant &p_variant);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

VariantComparator
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
struct VariantComparator {
	static bool compare(const Variant &p_lhs, const Variant &p_rhs);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


CLASSES
====================================================================================


RLogger
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class RLogger {
public:
	static void print_trace(const String &str);
	static void print_trace(const char *str);
	static void print_trace(const char *p_function, const char *p_file, int p_line, const String &str);
	static void print_trace(const char *p_function, const char *p_file, int p_line, const char *str);

	static void print_message(const String &str);
	static void print_message(const char *str);
	static void print_message(const char *p_function, const char *p_file, int p_line, const String &str);
	static void print_message(const char *p_function, const char *p_file, int p_line, const char *str);

	static void print_warning(const String &str);
	static void print_warning(const char *str);
	static void print_warning(const char *p_function, const char *p_file, int p_line, const String &str);
	static void print_warning(const char *p_function, const char *p_file, int p_line, const char *str);

	static void print_error(const String &str);
	static void print_error(const char *str);
	static void print_error(const char *p_function, const char *p_file, int p_line, const char *str);
	static void print_error(const char *p_function, const char *p_file, int p_line, const String &str);
	static void print_msg_error(const char *p_function, const char *p_file, int p_line, const char *p_msg, const char *str);
	static void print_index_error(const char *p_function, const char *p_file, int p_line, const int index, const int size, const char *str);

	static void log_trace(const String &str);
	static void log_trace(const char *str);
	static void log_trace(const char *p_function, const char *p_file, int p_line, const String &str);
	static void log_trace(const char *p_function, const char *p_file, int p_line, const char *str);

	static void log_message(const String &str);
	static void log_message(const char *str);
	static void log_message(const char *p_function, const char *p_file, int p_line, const String &str);
	static void log_message(const char *p_function, const char *p_file, int p_line, const char *str);

	static void log_warning(const String &str);
	static void log_warning(const char *str);
	static void log_warning(const char *p_function, const char *p_file, int p_line, const String &str);
	static void log_warning(const char *p_function, const char *p_file, int p_line, const char *str);

	static void log_error(const String &str);
	static void log_error(const char *str);
	static void log_error(const char *p_function, const char *p_file, int p_line, const char *str);
	static void log_error(const char *p_function, const char *p_file, int p_line, const String &str);
	static void log_msg_error(const char *p_function, const char *p_file, int p_line, const char *p_msg, const char *str);
	static void log_index_error(const char *p_function, const char *p_file, int p_line, const int index, const int size, const char *str);
	static void log_index_error(const char *p_function, const char *p_file, int p_line, const int index, const int size, const String &str);

	static String *get_string_ptr(const int p_default_size = 100);
	static String *get_string_ptr(const char *p_function, const char *p_file, int p_line, const int p_default_size = 300);
	static String *get_string_ptr(const char *p_prefix, const char *p_function, const char *p_file, int p_line, const int p_default_size = 300);
	static void return_string_ptr(String *str);

	static String *get_trace_string_ptr(const int p_default_size = 100);
	static String *get_message_string_ptr(const int p_default_size = 100);
	static String *get_warning_string_ptr(const int p_default_size = 100);
	static String *get_error_string_ptr(const int p_default_size = 100);

	static String *get_trace_string_ptr(const char *p_function, const char *p_file, int p_line, const int p_default_size = 300);
	static String *get_message_string_ptr(const char *p_function, const char *p_file, int p_line, const int p_default_size = 300);
	static String *get_warning_string_ptr(const char *p_function, const char *p_file, int p_line, const int p_default_size = 300);
	static String *get_error_string_ptr(const char *p_function, const char *p_file, int p_line, const int p_default_size = 300);

	static void log_ptr(String *str);
	static void log_ret_ptr(String *str);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

STime
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class STime {
public:
	static uint64_t date();
	static uint64_t date_epoch();
	static char *date_string();
	static double time_hh();
	static double time_mm();
	static double time_ss();
	static uint64_t time_ms();
	static uint64_t time_us();
	static uint64_t time_ns();
	static void sleep_ss(double ss);
	static void sleep_ms(double ms);
	static void sleep_us(double us);
	static void sleep_ns(double us);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SafeNumeric
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class SafeNumeric {
	std::atomic<T> value;

public:
	_ALWAYS_INLINE_ void set(T p_value);

	_ALWAYS_INLINE_ T get();

	_ALWAYS_INLINE_ T increment();

	_ALWAYS_INLINE_ T postincrement();

	_ALWAYS_INLINE_ T decrement();

	_ALWAYS_INLINE_ T postdecrement();

	_ALWAYS_INLINE_ T add(T p_value);

	_ALWAYS_INLINE_ T postadd(T p_value);

	_ALWAYS_INLINE_ T sub(T p_value);

	_ALWAYS_INLINE_ T postsub(T p_value);

	_ALWAYS_INLINE_ T exchange_if_greater(T p_value);

	_ALWAYS_INLINE_ T conditional_increment();

	_ALWAYS_INLINE_ explicit SafeNumeric<T>(T p_value = static_cast<T>(0);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SafeFlag
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class SafeFlag {
	std::atomic_bool flag;

public:
	_ALWAYS_INLINE_ bool is_set();

	_ALWAYS_INLINE_ void set();

	_ALWAYS_INLINE_ void clear();

	_ALWAYS_INLINE_ void set_to(bool p_value);

	_ALWAYS_INLINE_ explicit SafeFlag(bool p_value = false);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SafeRefCount
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class SafeRefCount {
	SafeNumeric<uint32_t> count;

public:
	_ALWAYS_INLINE_ bool ref();

	_ALWAYS_INLINE_ uint32_t refval();

	_ALWAYS_INLINE_ bool unref();

	_ALWAYS_INLINE_ uint32_t unrefval();

	_ALWAYS_INLINE_ uint32_t get();

	_ALWAYS_INLINE_ void init(uint32_t p_value = 1);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SafeNumeric
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class SafeNumeric {
protected:
	T value;

public:
	_ALWAYS_INLINE_ void set(T p_value);

	_ALWAYS_INLINE_ T get();

	_ALWAYS_INLINE_ T increment();

	_ALWAYS_INLINE_ T postincrement();

	_ALWAYS_INLINE_ T decrement();

	_ALWAYS_INLINE_ T postdecrement();

	_ALWAYS_INLINE_ T add(T p_value);

	_ALWAYS_INLINE_ T postadd(T p_value);

	_ALWAYS_INLINE_ T sub(T p_value);

	_ALWAYS_INLINE_ T postsub(T p_value);

	_ALWAYS_INLINE_ T exchange_if_greater(T p_value);

	_ALWAYS_INLINE_ T conditional_increment();

	_ALWAYS_INLINE_ explicit SafeNumeric<T>(T p_value = static_cast<T>(0);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SafeFlag
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class SafeFlag {
protected:
	bool flag;

public:
	_ALWAYS_INLINE_ bool is_set();

	_ALWAYS_INLINE_ void set();

	_ALWAYS_INLINE_ void clear();

	_ALWAYS_INLINE_ void set_to(bool p_value);

	_ALWAYS_INLINE_ explicit SafeFlag(bool p_value = false);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SafeRefCount
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class SafeRefCount {
	uint32_t count;

public:
	_ALWAYS_INLINE_ bool ref();

	_ALWAYS_INLINE_ uint32_t refval();

	_ALWAYS_INLINE_ bool unref();

	_ALWAYS_INLINE_ uint32_t unrefval();

	_ALWAYS_INLINE_ uint32_t get();

	_ALWAYS_INLINE_ void init(uint32_t p_value = 1);

	SafeRefCount();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Memory
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class Memory {
#ifdef DEBUG_ENABLED
	static SafeNumeric<uint64_t> mem_usage;
	static SafeNumeric<uint64_t> max_usage;
#endif

	static SafeNumeric<uint64_t> alloc_count;

public:
	static void *alloc_static(size_t p_bytes, bool p_pad_align = false);
	static void *realloc_static(void *p_memory, size_t p_bytes, bool p_pad_align = false);
	static void free_static(void *p_ptr, bool p_pad_align = false);

	static uint64_t get_mem_available();
	static uint64_t get_mem_usage();
	static uint64_t get_mem_max_usage();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

DefaultAllocator
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class DefaultAllocator {
public:
	static void *alloc(size_t p_memory);
	static void free(void *p_ptr);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

MutexImpl
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class MutexImpl {
	mutable StdMutexT mutex;
	friend class MutexLock;

public:
	_ALWAYS_INLINE_ void lock();

	_ALWAYS_INLINE_ void unlock();

	_ALWAYS_INLINE_ Error try_lock();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

MutexLock
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class MutexLock {
	union {
		std::recursive_mutex *recursive_mutex;
		std::mutex *mutex;
	};
	bool recursive;

public:
	_ALWAYS_INLINE_ explicit MutexLock(const MutexImpl<std::recursive_mutex> &p_mutex);
	_ALWAYS_INLINE_ explicit MutexLock(const MutexImpl<std::mutex> &p_mutex);

	_ALWAYS_INLINE_ ~MutexLock();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

FakeMutex
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class FakeMutex {
	FakeMutex();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

MutexImpl
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class MutexImpl {
public:
	_ALWAYS_INLINE_ void lock();
	_ALWAYS_INLINE_ void unlock();
	_ALWAYS_INLINE_ Error try_lock();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

MutexLock
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class MutexLock {
public:
	explicit MutexLock(const MutexImpl<FakeMutex> &p_mutex);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

RWLock
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class RWLock {
	mutable std::shared_timed_mutex mutex;

public:
	
	void read_lock();

	void read_unlock();

	Error read_try_lock();

	void write_lock();

	void write_unlock();

	Error write_try_lock();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

RWLock
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class RWLock {
public:
	void read_lock();
	void read_unlock();
	Error read_try_lock();

	void write_lock();
	void write_unlock();
	Error write_try_lock();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

RWLockRead
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class RWLockRead {
	const RWLock &lock;

public:
	RWLockRead(const RWLock &p_lock);
	~RWLockRead();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

RWLockWrite
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class RWLockWrite {
	RWLock &lock;

public:
	RWLockWrite(RWLock &p_lock);
	~RWLockWrite();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SpinLock
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class SpinLock {
	std::atomic_flag locked = ATOMIC_FLAG_INIT;

public:
	_ALWAYS_INLINE_ void lock();
	_ALWAYS_INLINE_ void unlock();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

RandomPCG
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class RandomPCG {
	pcg32_random_t pcg;
	uint64_t current_seed; 
	uint64_t current_inc;

public:
	static const uint64_t DEFAULT_SEED = 12047754176567800795U;
	static const uint64_t DEFAULT_INC = PCG_DEFAULT_INC_64;

	RandomPCG(uint64_t p_seed = DEFAULT_SEED, uint64_t p_inc = DEFAULT_INC);

	void seed(uint64_t p_seed);
	uint64_t get_seed();

	void set_state(uint64_t p_state);
	uint64_t get_state();

	void randomize();
	uint32_t rand();
	uint32_t rand(uint32_t bounds);

	double randd();
	float randf();

	double randfn(double p_mean, double p_deviation);
	float randfn(float p_mean, float p_deviation);

	double random(double p_from, double p_to);
	float random(float p_from, float p_to);
	real_t randomr(real_t p_from, real_t p_to);
	int random(int p_from, int p_to);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Math
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class Math {
	static RandomPCG default_rand;

public:
	Math();

	static const uint64_t RANDOM_32BIT_MAX = 0xFFFFFFFF;

	static _ALWAYS_INLINE_ double sin(double p_x);
	static _ALWAYS_INLINE_ float sin(float p_x);

	static _ALWAYS_INLINE_ double cos(double p_x);
	static _ALWAYS_INLINE_ float cos(float p_x);

	static _ALWAYS_INLINE_ double tan(double p_x);
	static _ALWAYS_INLINE_ float tan(float p_x);

	static _ALWAYS_INLINE_ double sinh(double p_x);
	static _ALWAYS_INLINE_ float sinh(float p_x);

	static _ALWAYS_INLINE_ float sinc(float p_x);
	static _ALWAYS_INLINE_ double sinc(double p_x);

	static _ALWAYS_INLINE_ float sincn(float p_x);
	static _ALWAYS_INLINE_ double sincn(double p_x);

	static _ALWAYS_INLINE_ double cosh(double p_x);
	static _ALWAYS_INLINE_ float cosh(float p_x);

	static _ALWAYS_INLINE_ double tanh(double p_x);
	static _ALWAYS_INLINE_ float tanh(float p_x);

	static _ALWAYS_INLINE_ double asin(double p_x);
	static _ALWAYS_INLINE_ float asin(float p_x);

	static _ALWAYS_INLINE_ double acos(double p_x);
	static _ALWAYS_INLINE_ float acos(float p_x);

	static _ALWAYS_INLINE_ double asin_unsafe(double p_x);
	static _ALWAYS_INLINE_ float asin_unsafe(float p_x);

	static _ALWAYS_INLINE_ double acos_unsafe(double p_x);
	static _ALWAYS_INLINE_ float acos_unsafe(float p_x);

	static _ALWAYS_INLINE_ double atan(double p_x);
	static _ALWAYS_INLINE_ float atan(float p_x);

	static _ALWAYS_INLINE_ double atan2(double p_y, double p_x);
	static _ALWAYS_INLINE_ float atan2(float p_y, float p_x);

	static _ALWAYS_INLINE_ double sqrt(double p_x);
	static _ALWAYS_INLINE_ float sqrt(float p_x);

	static _ALWAYS_INLINE_ double fmod(double p_x, double p_y);
	static _ALWAYS_INLINE_ float fmod(float p_x, float p_y);

	static _ALWAYS_INLINE_ double floor(double p_x);
	static _ALWAYS_INLINE_ float floor(float p_x);
	
	static _ALWAYS_INLINE_ int floorf_int(const float x);

	static _ALWAYS_INLINE_ double ceil(double p_x);
	static _ALWAYS_INLINE_ float ceil(float p_x);

	static _ALWAYS_INLINE_ double pow(double p_x, double p_y);
	static _ALWAYS_INLINE_ float pow(float p_x, float p_y);

	static _ALWAYS_INLINE_ double log(double p_x);
	static _ALWAYS_INLINE_ float log(float p_x);

	static _ALWAYS_INLINE_ double log1p(double p_x);
	static _ALWAYS_INLINE_ float log1p(float p_x);

	static _ALWAYS_INLINE_ double log10(double p_x);
	static _ALWAYS_INLINE_ float log10(float p_x);

	static _ALWAYS_INLINE_ double log2(double p_x);
	static _ALWAYS_INLINE_ float log2(float p_x);

	static _ALWAYS_INLINE_ double exp(double p_x);
	static _ALWAYS_INLINE_ float exp(float p_x);

	static _ALWAYS_INLINE_ double erf(double p_x);
	static _ALWAYS_INLINE_ float erf(float p_x);

	static float divf(const float a, const float b);

	static _ALWAYS_INLINE_ bool is_nan(double p_val);

	static _ALWAYS_INLINE_ bool is_nan(float p_val);

	static _ALWAYS_INLINE_ bool is_inf(double p_val);

	static _ALWAYS_INLINE_ bool is_inf(float p_val);

	static _ALWAYS_INLINE_ double abs(double g);
	static _ALWAYS_INLINE_ float abs(float g);
	static _ALWAYS_INLINE_ int abs(int g);
	static _ALWAYS_INLINE_ int64_t abs(int64_t g);
	static _ALWAYS_INLINE_ int absi(int g);
	static _ALWAYS_INLINE_ int64_t absi(int64_t g);

	static _ALWAYS_INLINE_ double fposmod(double p_x, double p_y);
	static _ALWAYS_INLINE_ float fposmod(float p_x, float p_y);

	static _ALWAYS_INLINE_ float fposmodp(float p_x, float p_y);
	static _ALWAYS_INLINE_ double fposmodp(double p_x, double p_y);

	static _ALWAYS_INLINE_ int64_t posmod(int64_t p_x, int64_t p_y);

	static _ALWAYS_INLINE_ double deg2rad(double p_y);
	static _ALWAYS_INLINE_ float deg2rad(float p_y);

	static _ALWAYS_INLINE_ double rad2deg(double p_y);
	static _ALWAYS_INLINE_ float rad2deg(float p_y);

	static _ALWAYS_INLINE_ double lerp(double p_from, double p_to, double p_weight);
	static _ALWAYS_INLINE_ float lerp(float p_from, float p_to, float p_weight);

	static _ALWAYS_INLINE_ double lerp_angle(double p_from, double p_to, double p_weight);
	static _ALWAYS_INLINE_ float lerp_angle(float p_from, float p_to, float p_weight);

	static _ALWAYS_INLINE_ double inverse_lerp(double p_from, double p_to, double p_value);
	static _ALWAYS_INLINE_ float inverse_lerp(float p_from, float p_to, float p_value);

	static _ALWAYS_INLINE_ double range_lerp(double p_value, double p_istart, double p_istop, double p_ostart, double p_ostop);
	static _ALWAYS_INLINE_ float range_lerp(float p_value, float p_istart, float p_istop, float p_ostart, float p_ostop);

	static _ALWAYS_INLINE_ double cubic_interpolate(double p_from, double p_to, double p_pre, double p_post, double p_weight);
	static _ALWAYS_INLINE_ float cubic_interpolate(float p_from, float p_to, float p_pre, float p_post, float p_weight);

	static _ALWAYS_INLINE_ double bezier_interpolate(double p_start, double p_control_1, double p_control_2, double p_end, double p_t);
	static _ALWAYS_INLINE_ float bezier_interpolate(float p_start, float p_control_1, float p_control_2, float p_end, float p_t);

	static _ALWAYS_INLINE_ double smoothstep(double p_from, double p_to, double p_s);
	static _ALWAYS_INLINE_ float smoothstep(float p_from, float p_to, float p_s);
	static _ALWAYS_INLINE_ double move_toward(double p_from, double p_to, double p_delta);
	static _ALWAYS_INLINE_ float move_toward(float p_from, float p_to, float p_delta);

	static _ALWAYS_INLINE_ double linear2db(double p_linear);
	static _ALWAYS_INLINE_ float linear2db(float p_linear);

	static _ALWAYS_INLINE_ double db2linear(double p_db);
	static _ALWAYS_INLINE_ float db2linear(float p_db);

	static _ALWAYS_INLINE_ double round(double p_val);
	static _ALWAYS_INLINE_ float round(float p_val);

	static _ALWAYS_INLINE_ int64_t wrapi(int64_t value, int64_t min, int64_t max);
	static _ALWAYS_INLINE_ double wrapf(double value, double min, double max);
	static _ALWAYS_INLINE_ float wrapf(float value, float min, float max);

	static _ALWAYS_INLINE_ float fract(float value);
	static _ALWAYS_INLINE_ double fract(double value);
	static _ALWAYS_INLINE_ float pingpong(float value, float length);
	static _ALWAYS_INLINE_ double pingpong(double value, double length);

	static double ease(double p_x, double p_c);
	static int step_decimals(double p_step);
	static int range_step_decimals(double p_step);
	static double stepify(double p_value, double p_step);
	static double dectime(double p_value, double p_amount, double p_step);

	static uint32_t larger_prime(uint32_t p_val);

	static void seed(uint64_t x);
	static void randomize();
	static uint32_t rand_from_seed(uint64_t *seed);
	static uint32_t rand();
	static _ALWAYS_INLINE_ double randd();
	static _ALWAYS_INLINE_ float randf();
	static double randfn(double mean, double deviation);

	static double random(double from, double to);
	static float random(float from, float to);
	static real_t randomr(real_t from, real_t to);
	static int random(int from, int to);
	static _ALWAYS_INLINE_ int randomi(int from, int to);

	static _ALWAYS_INLINE_ bool is_equal_approx_ratio(real_t a, real_t b, real_t epsilon = CMP_EPSILON, real_t min_epsilon = CMP_EPSILON);

	static _ALWAYS_INLINE_ bool is_equal_approx(float a, float b);

	static _ALWAYS_INLINE_ bool is_equal_approx(float a, float b, float tolerance);

	static _ALWAYS_INLINE_ bool is_equal_approxt(float a, float b, float tolerance);

	static _ALWAYS_INLINE_ bool is_zero_approx(float s);

	static _ALWAYS_INLINE_ bool is_equal_approx(double a, double b);

	static _ALWAYS_INLINE_ bool is_equal_approx(double a, double b, double tolerance);

	static _ALWAYS_INLINE_ bool is_zero_approx(double s);

	static _ALWAYS_INLINE_ float absf(float g);

	static _ALWAYS_INLINE_ double absd(double g);

	static _ALWAYS_INLINE_ int fast_ftoi(float a);

	static _ALWAYS_INLINE_ uint32_t halfbits_to_floatbits(uint16_t h);

	static _ALWAYS_INLINE_ float halfptr_to_float(const uint16_t *h);

	static _ALWAYS_INLINE_ float half_to_float(const uint16_t h);

	static _ALWAYS_INLINE_ uint16_t make_half_float(float f);

	static _ALWAYS_INLINE_ float snap_scalar(float p_offset, float p_step, float p_target);

	static _ALWAYS_INLINE_ float snap_scalar_separation(float p_offset, float p_step, float p_target, float p_separation);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

CowData
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class CowData {
	template <class TV>
	friend class Vector;
	friend class String;
	friend class Char16String;
	friend class CharString;
	template <class TV, class VV>
	friend class VMap;

private:
	mutable T *_ptr;

	SafeNumeric<uint32_t> *_get_refcount();

	uint32_t *_get_size();

	size_t _get_alloc_size(size_t p_elements);

	bool _get_alloc_size_checked(size_t p_elements, size_t *out);

	void _unref(void *p_data);
	void _ref(const CowData *p_from);
	void _ref(const CowData &p_from);
	uint32_t _copy_on_write();

public:
	void operator=(const CowData<T> &p_from);

	T *ptrw();

	const T *ptr();

	int size();

	void clear();
	bool empty();

	void set(int p_index, const T &p_elem);

	T &get_m(int p_index);

	const T &get(int p_index);

	Error resize(int p_size);

	void remove(int p_index);

	Error insert(int p_pos, const T &p_val);

	void fill(const T &p_val);

	int find(const T &p_val, int p_from = 0);

	CowData();
	~CowData();
	CowData(CowData<T> &p_from);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SortArray
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class SortArray {
	enum {

		INTROSORT_THRESHOLD = 16
	};

public:
	Comparator compare;

	const T &median_of_3(const T &a, const T &b, const T &c);

	int bitlog(int n);

	void push_heap(int p_first, int p_hole_idx, int p_top_index, T p_value, T *p_array);

	void pop_heap(int p_first, int p_last, int p_result, T p_value, T *p_array);
	void pop_heap(int p_first, int p_last, T *p_array);

	void adjust_heap(int p_first, int p_hole_idx, int p_len, T p_value, T *p_array);

	void sort_heap(int p_first, int p_last, T *p_array);

	void make_heap(int p_first, int p_last, T *p_array);

	void partial_sort(int p_first, int p_last, int p_middle, T *p_array);

	void partial_select(int p_first, int p_last, int p_middle, T *p_array);

	int partitioner(int p_first, int p_last, T p_pivot, T *p_array);

	void introsort(int p_first, int p_last, T *p_array, int p_max_depth);

	void introselect(int p_first, int p_nth, int p_last, T *p_array, int p_max_depth);

	void unguarded_linear_insert(int p_last, T p_value, T *p_array);

	void linear_insert(int p_first, int p_last, T *p_array);

	void insertion_sort(int p_first, int p_last, T *p_array);

	void unguarded_insertion_sort(int p_first, int p_last, T *p_array);

	void final_insertion_sort(int p_first, int p_last, T *p_array);

	void sort_range(int p_first, int p_last, T *p_array);

	void sort(T *p_array, int p_len);

	void nth_element(int p_first, int p_last, int p_nth, T *p_array);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

RBMap
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class RBMap {
	enum Color {
		RED,
		BLACK
	};
	struct _Data;

public:
	class Element {
	private:
		friend class RBMap<K, V, C, A>;
		int color;
		Element *right;
		Element *left;
		Element *parent;
		Element *_next;
		Element *_prev;
		K _key;
		V _value;
		
	public:
		const Element *next();
		Element *next();
		const Element *prev();
		Element *prev();
		const K &key();
		V &value();
		const V &value();
		V &get();
		const V &get();
		Element();
	};

private:
	struct _Data {
		Element *_root;
		Element *_nil;
		int size_cache;

		_Data();

		void _create_root();

		void _free_root();

		~_Data();
	};

	_Data _data;

	void _set_color(Element *p_node, int p_color);

	void _rotate_left(Element *p_node);

	void _rotate_right(Element *p_node);

	Element *_successor(Element *p_node);

	Element *_predecessor(Element *p_node);

	Element *_find(const K &p_key);

	Element *_find_closest(const K &p_key);

	void _insert_rb_fix(Element *p_new_node);

	Element *_insert(const K &p_key, const V &p_value);

	void _erase_fix_rb(Element *p_node);

	void _erase(Element *p_node);

	void _calculate_depth(Element *p_element, int &max_d, int d);

	void _cleanup_tree(Element *p_element);

	void _copy_from(const RBMap &p_map);

public:
	const Element *find(const K &p_key);

	Element *find(const K &p_key);

	const Element *find_closest(const K &p_key);

	Element *find_closest(const K &p_key);

	bool has(const K &p_key);

	Element *insert(const K &p_key, const V &p_value);

	void erase(Element *p_element);

	bool erase(const K &p_key);

	const V &operator[](const K &p_key);

	V &operator[](const K &p_key);

	Element *front();

	Element *back();

	bool empty();
	int size();

	int calculate_depth();

	void clear();

	void operator=(const RBMap &p_map);

	RBMap(const RBMap &p_map);

	RBMap();

	~RBMap();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

RBSet
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class RBSet {
	enum Color {
		RED,
		BLACK
	};
	struct _Data;

public:
	class Element {
	private:
		friend class RBSet<T, C, A>;
		int color;
		Element *right;
		Element *left;
		Element *parent;
		Element *_next;
		Element *_prev;
		T value;
		
	public:
		const Element *next();
		Element *next();
		const Element *prev();
		Element *prev();
		const T &get();
		Element();
	};

private:
	struct _Data {
		Element *_root;
		Element *_nil;
		int size_cache;

		_Data();

		void _create_root();

		void _free_root();

		~_Data();
	};

	_Data _data;

	void _set_color(Element *p_node, int p_color);

	void _rotate_left(Element *p_node);

	void _rotate_right(Element *p_node);

	Element *_successor(Element *p_node);

	Element *_predecessor(Element *p_node);

	Element *_find(const T &p_value);

	Element *_lower_bound(const T &p_value);

	void _insert_rb_fix(Element *p_new_node);

	Element *_insert(const T &p_value);

	void _erase_fix_rb(Element *p_node);

	void _erase(Element *p_node);

	void _calculate_depth(Element *p_element, int &max_d, int d);

	void _cleanup_tree(Element *p_element);

	void _copy_from(const RBSet &p_set);

public:
	const Element *find(const T &p_value);

	Element *find(const T &p_value);

	Element *lower_bound(const T &p_value);

	bool has(const T &p_value);

	Element *insert(const T &p_value);

	void erase(Element *p_element);

	bool erase(const T &p_value);

	Element *front();

	Element *back();

	bool empty();
	int size();

	int calculate_depth();

	void clear();

	void operator=(const RBSet &p_set);

	RBSet(const RBSet &p_set);

	RBSet();

	~RBSet();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

VMap
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class VMap {
public:
	struct Pair {
		T key;
		V value;

		Pair();

		Pair(const T &p_key, const V &p_value);
	};

private:
	CowData<Pair> _cowdata;

	int _find(const T &p_val, bool &r_exact);

	int _find_exact(const T &p_val);

public:
	int insert(const T &p_key, const V &p_val);

	bool has(const T &p_val);

	void erase(const T &p_val);

	int find(const T &p_val);

	int find_nearest(const T &p_val);

	int size();
	bool empty();

	const Pair *get_array();

	Pair *get_array();

	const V &getv(int p_index);

	V &getv(int p_index);

	const T &getk(int p_index);

	T &getk(int p_index);

	const V &operator[](const T &p_key);

	V &operator[](const T &p_key);

	VMap();
	VMap(const VMap &p_from);
	VMap &operator=(const VMap &p_from);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

VectorWriteProxy
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class VectorWriteProxy {
public:
	T &operator[](int p_index);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Vector
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class Vector {
	friend class VectorWriteProxy<T>;

public:
	VectorWriteProxy<T> write;

private:
	CowData<T> _cowdata;

public:
	bool push_back(T p_elem);

	void remove(int p_index);
	bool erase(const T &p_val);
	void invert();

	T *ptrw();
	const T *ptr();
	void clear();
	bool empty();

	T get(int p_index);
	const T &get(int p_index);
	void set(int p_index, const T &p_elem);
	int size();
	Error resize(int p_size);
	const T &operator[](int p_index);
	Error insert(int p_pos, T p_val);
	int find(const T &p_val, int p_from = 0);
	void fill(const T &p_val);

	void append_array(Vector<T> p_other);

	template <class C>
	void sort_custom();

	void sort();

	void ordered_insert(const T &p_val);

	Vector();
	Vector(const Vector &p_from);
	Vector &operator=(const Vector &p_from);

	Vector<uint8_t> to_byte_array();

	Vector<T> slice(int p_begin, int p_end = INT32_MAX);

	~Vector();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

VSet
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class VSet {
	Vector<T> _data;

	int _find(const T &p_val, bool &r_exact);

	int _find_exact(const T &p_val);

public:
	void insert(const T &p_val);

	bool has(const T &p_val);

	void erase(const T &p_val);

	int find(const T &p_val);

	bool empty();

	int size();

	T &operator[](int p_index);

	const T &operator[](int p_index);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

List
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class List {
	struct _Data;

public:
	class Element {
	private:
		friend class List<T, A>;

		T value;
		Element *next_ptr;
		Element *prev_ptr;
		_Data *data;

	public:
		
		const Element *next();
		
		Element *next();

		const Element *prev();
		
		Element *prev();

		const T &operator*();
		
		const T *operator->();
		
		T &operator*();
		
		T *operator->();

		T &get();
		
		const T &get();
		
		void set(const T &p_value);

		void erase();

		Element();
	};

private:
	struct _Data {
		Element *first;
		Element *last;
		int size_cache;

		bool erase(const Element *p_I);
	};

	_Data *_data;

public:
	
	const Element *front();

	Element *front();

	const Element *back();

	Element *back();

	Element *push_back(const T &value);

	void pop_back();

	Element *push_front(const T &value);

	void pop_front();

	Element *insert_after(Element *p_element, const T &p_value);

	Element *insert_before(Element *p_element, const T &p_value);

	template <class T_v>
	Element *find(const T_v &p_val);

	bool erase(const Element *p_I);

	bool erase(const T &value);

	bool empty();

	void clear();

	int size();

	void swap(Element *p_A, Element *p_B);
	
	void operator=(const List &p_list);

	T &operator[](int p_index);

	const T &operator[](int p_index);

	void move_to_back(Element *p_I);

	void invert();

	void move_to_front(Element *p_I);

	void move_before(Element *value, Element *where);

	void sort();

	template <class C>
	void sort_custom_inplace();

	template <class C>
	struct AuxiliaryComparator {
		C compare;
		bool operator();
	};

	template <class C>
	void sort_custom();

	const void *id();

	List(const List &p_list);

	List();
	~List();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

RingBuffer
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class RingBuffer {
	Vector<T> data;
	int read_pos;
	int write_pos;
	int size_mask;

	int inc(int &p_var, int p_size);

public:
	T read();

	int read(T *p_buf, int p_size, bool p_advance = true);

	int copy(T *p_buf, int p_offset, int p_size);

	int find(const T &t, int p_offset, int p_max_size);

	int advance_read(int p_n);

	int decrease_write(int p_n);

	Error write(const T &p_v);

	int write(const T *p_buf, int p_size);

	int space_left();
	int data_left();

	int size();

	void clear();

	void resize(int p_power);

	RingBuffer<T>(int p_power = 0);
	~RingBuffer<T>();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

PagedAllocator
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class PagedAllocator {
	T **page_pool = nullptr;
	T ***available_pool = nullptr;
	uint32_t pages_allocated = 0;
	uint32_t allocs_available = 0;

	uint32_t page_shift = 0;
	uint32_t page_mask = 0;
	uint32_t page_size = 0;
	SpinLock spin_lock;

public:
	T *alloc();

	void free(T *p_mem);

	void reset(bool p_allow_unfreed = false);
	bool is_configured();

	void configure(uint32_t p_page_size);

	PagedAllocator(uint32_t p_page_size = 4096);

	~PagedAllocator();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

PoolAllocator
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class PoolAllocator {
public:
	typedef int ID;

private:
	enum {
		CHECK_BITS = 8,
		CHECK_LEN = (1 << CHECK_BITS);
		unsigned int len;
		unsigned int lock;
		unsigned int check;

		void clear();
		Entry();
	};

	typedef int EntryArrayPos;
	typedef int EntryIndicesPos;

	Entry *entry_array;
	int *entry_indices;
	int entry_max;
	int entry_count;

	uint8_t *pool;
	void *mem_ptr;
	int pool_size;

	int free_mem;
	int free_mem_peak;

	unsigned int check_count;
	int align;

	bool needs_locking;

	int entry_end(const Entry &p_entry);
	int aligned(int p_size);

	void compact(int p_up_to = -1);
	void compact_up(int p_from = 0);
	bool get_free_entry(EntryArrayPos *p_pos);
	bool find_hole(EntryArrayPos *p_pos, int p_for_size);
	bool find_entry_index(EntryIndicesPos *p_map_pos, Entry *p_entry);
	Entry *get_entry(ID p_mem);
	const Entry *get_entry(ID p_mem);

	void create_pool(void *p_mem, int p_size, int p_max_entries);

protected:
	virtual void mt_lock();
	virtual void mt_unlock();

public:
	enum {
		DEFAULT_MAX_ALLOCS = 4096,
	};

	ID alloc(int p_size);
	void free(ID p_mem);
	Error resize(ID p_mem, int p_new_size);
	int get_size(ID p_mem);

	int get_free_mem();
	int get_used_mem();
	int get_free_peak();

	Error lock(ID p_mem);
	void *get(ID p_mem);
	const void *get(ID p_mem);
	void unlock(ID p_mem);
	bool is_locked(ID p_mem);

	PoolAllocator(int p_size, bool p_needs_locking = false, int p_max_entries = DEFAULT_MAX_ALLOCS);
	PoolAllocator(void *p_mem, int p_size, int p_align = 1, bool p_needs_locking = false, int p_max_entries = DEFAULT_MAX_ALLOCS);
	PoolAllocator(int p_align, int p_size, bool p_needs_locking = false, int p_max_entries = DEFAULT_MAX_ALLOCS);

	virtual ~PoolAllocator();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

CharProxy
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class CharProxy {
	friend class Char16String;
	friend class CharString;
	friend class String;

	const int _index;
	CowData<T> &_cowdata;
	static const T _null = 0;

	CharProxy(const int &p_index, CowData<T> &p_cowdata);

public:
	CharProxy(const CharProxy<T> &p_other);

	operator T();

	const T *operator&();

	void operator=(const T &p_other);

	void operator=(const CharProxy<T> &p_other);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Char16String
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class Char16String {
	CowData<char16_t> _cowdata;
	static const char16_t _null;

public:
	char16_t *ptrw();
	const char16_t *ptr();
	int size();
	Error resize(int p_size);

	char16_t get(int p_index);
	void set(int p_index, const char16_t &p_elem);
	const char16_t &operator[](int p_index);
	CharProxy<char16_t> operator[](int p_index);

	Char16String();
	Char16String(const Char16String &p_str);
	void operator=(const Char16String &p_str);
	Char16String(const char16_t *p_cstr);

	void operator=(const char16_t *p_cstr);
	bool operator<(const Char16String &p_right);
	Char16String &operator+=(char16_t p_char);
	int length();
	const char16_t *get_data();
	operator const char16_t *();

protected:
	void copy_from(const char16_t *p_cstr);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

CharString
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class CharString {
	CowData<char> _cowdata;
	static const char _null;

public:
	char *ptrw();
	const char *ptr();
	int size();
	Error resize(int p_size);

	char get(int p_index);
	void set(int p_index, const char &p_elem);
	const char &operator[](int p_index);
	CharProxy<char> operator[](int p_index);

	CharString();
	CharString(const CharString &p_str);
	void operator=(const CharString &p_str);
	CharString(const char *p_cstr);

	void operator=(const char *p_cstr);
	bool operator<(const CharString &p_right);
	CharString &operator+=(char p_char);
	int length();
	const char *get_data();
	operator const char *();

protected:
	void copy_from(const char *p_cstr);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

String
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class String {
public:
	enum {
		npos = -1 
	};

	CharType *ptrw();
	const CharType *ptr();

	void remove(int p_index);

	void clear();

	CharType get(int p_index);
	void set(int p_index, const CharType &p_elem);
	int size();
	Error resize(int p_size);
	Error set_length(int p_length);

	const CharType &operator[](int p_index);
	CharProxy<CharType> operator[](int p_index);

	bool operator==(const String &p_str);
	bool operator!=(const String &p_str);
	String operator+(const String &p_str);
	
	String &operator+=(const String &);
	String &operator+=(CharType p_char);
	String &operator+=(const char *p_str);
	String &operator+=(const wchar_t *p_str);
	String &operator+=(const CharType *p_str);

	void operator=(const char *p_str);
	void operator=(const wchar_t *p_str);
	void operator=(const CharType *p_str);

	bool operator==(const char *p_str);
	bool operator==(const wchar_t *p_str);
	bool operator==(const CharType *p_str);
	bool operator==(const StrRange &p_str_range);

	bool operator!=(const char *p_str);
	bool operator!=(const wchar_t *p_str);
	bool operator!=(const CharType *p_str);

	bool operator<(const CharType *p_str);
	bool operator<(const char *p_str);
	bool operator<(const wchar_t *p_str);

	bool operator<(const String &p_str);
	bool operator<=(const String &p_str);
	bool operator>(const String &p_str);
	bool operator>=(const String &p_str);

	signed char casecmp_to(const String &p_str);
	signed char nocasecmp_to(const String &p_str);
	signed char naturalnocasecmp_to(const String &p_str);

	const CharType *get_data();

	int length();

	bool is_valid_string();

	void print_unicode_error(const String &p_message, bool p_critical = false);

	String substr(int p_from, int p_chars = -1);
	String substr_index(const int p_start_index, const int p_end_index);

	int find(const String &p_str, int p_from = 0);
	int find(const char *p_str, int p_from = 0);
	int find_char(const CharType &p_char, int p_from = 0);
	int find_last(const String &p_str);
	int findn(const String &p_str, int p_from = 0);
	int rfind(const String &p_str, int p_from = -1);
	int rfindn(const String &p_str, int p_from = -1);
	int findmk(const Vector<String> &p_keys, int p_from = 0, int *r_key = nullptr);
	int find_first_difference_index(const String &p_str);

	bool is_word_at(const int p_index, const char *p_str);
	bool is_word_at(const int p_index, const String &p_str);

	bool match(const String &p_wildcard);
	bool matchn(const String &p_wildcard);

	bool begins_with(const String &p_string);
	bool begins_with(const char *p_string);
	bool ends_with(const String &p_string);

	bool is_enclosed_in(const String &p_string);
	bool is_subsequence_of(const String &p_string);
	bool is_subsequence_ofi(const String &p_string);
	bool is_quoted();

	Vector<String> bigrams();
	float similarity(const String &p_string);
	
	String replace_first(const String &p_key, const String &p_with);
	String replace(const String &p_key, const String &p_with);
	String replace(const char *p_key, const char *p_with);
	String replacen(const String &p_key, const String &p_with);

	String newline_to_br();

	String repeat(int p_count);
	String insert(int p_at_pos, const String &p_string);

	String pad_decimals(int p_digits);
	String pad_zeros(int p_digits);

	String trim_prefix(const String &p_prefix);
	String trim_suffix(const String &p_suffix);

	String lpad(int min_length, const String &character = " ");
	String rpad(int min_length, const String &character = " ");

	String quote(String quotechar = "\"");
	String unquote();

	static String num(double p_num, int p_decimals = -1);
	static String num_scientific(double p_num);
	static String num_real(double p_num);
	static String num_int64(int64_t p_num, int base = 10, bool capitalize_hex = false);
	static String num_uint64(uint64_t p_num, int base = 10, bool capitalize_hex = false);

	static String chr(CharType p_char);

	static String md5(const uint8_t *p_md5);

	static String hex_encode_buffer(const uint8_t *p_buffer, int p_len);

	static String bool_num(bool p_val);
	static String bool_str(bool p_val);

	bool is_numeric();
	bool is_zero();

	double to_double();
	float to_float();
	int to_int();
	bool to_bool();
	uint32_t to_uint();

	int hex_to_int(bool p_with_prefix = true);
	int64_t hex_to_int64(bool p_with_prefix = true);
	int64_t bin_to_int64(bool p_with_prefix = true);
	int64_t to_int64();

	static int64_t to_int(const char *p_str, int p_len = -1);
	static int64_t to_int(const wchar_t *p_str, int p_len = -1);
	static int64_t to_int(const CharType *p_str, int p_len = -1, bool p_clamp = false);

	static double to_float(const char *p_str);
	static double to_float(const wchar_t *p_str, const wchar_t **r_end = nullptr);
	static double to_float(const CharType *p_str, const CharType **r_end = nullptr);

	static double to_double(const char *p_str);
	static double to_double(const wchar_t *p_str, const wchar_t **r_end = nullptr);
	static double to_double(const CharType *p_str, const CharType **r_end = nullptr);

	static uint32_t num_characters(int64_t p_int);

	String capitalize();
	String camelcase_to_underscore(bool lowercase = true);

	int get_slice_count(String p_splitter);
	String get_slice(String p_splitter, int p_slice);
	String get_slicec(CharType p_splitter, int p_slice);

	Vector<String> split(const String &p_splitter, bool p_allow_empty = true, int p_maxsplit = 0);
	Vector<String> rsplit(const String &p_splitter, bool p_allow_empty = true, int p_maxsplit = 0);
	Vector<String> split_spaces();
	Vector<float> split_floats(const String &p_splitter, bool p_allow_empty = true);
	Vector<float> split_floats_mk(const Vector<String> &p_splitters, bool p_allow_empty = true);
	Vector<int> split_ints(const String &p_splitter, bool p_allow_empty = true);
	Vector<int> split_ints_mk(const Vector<String> &p_splitters, bool p_allow_empty = true);

	String join(const Vector<String> &parts);

	static CharType char_uppercase(CharType p_char);
	static CharType char_lowercase(CharType p_char);
	String to_upper();
	String to_lower();

	int count(const String &p_string, int p_from = 0, int p_to = 0);
	int countn(const String &p_string, int p_from = 0, int p_to = 0);

	String left(int p_pos);
	String right(int p_pos);
	String indent(const String &p_prefix);
	String dedent();

	String strip_edges(bool left = true, bool right = true);
	String strip_escapes();
	String lstrip(const String &p_chars);
	String rstrip(const String &p_chars);

	String get_extension();
	String get_basename();
	String plus_file(const String &p_file);

	CharType unicode_at(int p_idx);
	CharType ord_at(int p_idx);

	void erase(int p_pos, int p_chars);

	CharString ascii(bool p_allow_extended = false);
	CharString utf8();
	Error parse_utf8(const char *p_utf8, int p_len = -1, bool p_skip_cr = false);
	static String utf8(const char *p_utf8, int p_len = -1);
	int utf8_byte_length();

	Char16String utf16();
	Error parse_utf16(const char16_t *p_utf16, int p_len = -1);
	static String utf16(const char16_t *p_utf16, int p_len = -1);
	int utf16_byte_length();

	static uint32_t hash(const char *p_cstr);
	static uint32_t hash(const char *p_cstr, int p_len);
	static uint32_t hash(const wchar_t *p_cstr);
	static uint32_t hash(const wchar_t *p_cstr, int p_len);
	static uint32_t hash(const CharType *p_cstr);
	static uint32_t hash(const CharType *p_cstr, int p_len);

	uint32_t hash();
	uint64_t hash64();

	bool empty();
	bool contains(const char *p_str);
	bool contains(const String &p_str);

	bool is_abs_path();
	bool is_rel_path();
	bool is_resource_file();
	String path_to(const String &p_path);
	String path_to_file(const String &p_path);
	String get_base_dir();
	String get_file();
	static String humanize_size(uint64_t p_size);
	String simplify_path();
	bool is_network_share_path();
	String append_path(const char *p_path);
	String append_path(const String &p_path);
	String path_clean_end_slash();
	String path_ensure_end_slash();
	String path_get_prev_dir();

	String xml_escape(bool p_escape_quotes = false);
	String xml_unescape();
	String http_escape();
	String http_unescape();
	String uri_encode();
	String uri_decode();
	String c_escape();
	String c_escape_multiline();
	String c_unescape();
	String json_escape();
	String word_wrap(int p_chars_per_line);
	Error parse_url(String &r_scheme, String &r_host, int &r_port, String &r_path);

	String percent_encode();
	String percent_decode();

	String property_name_encode();

	static String get_invalid_node_name_characters();
	String validate_node_name();
	String validate_identifier();

	bool is_valid_identifier();
	bool is_valid_integer();
	bool is_valid_float();
	bool is_valid_hex_number(bool p_with_prefix);
	bool is_valid_html_color();
	bool is_valid_ip_address();
	bool is_valid_filename();
	bool is_valid_bool();
	bool is_valid_unsigned_integer();

	String();
	String(const String &p_str);

	void operator=(const String &p_str);

	Vector<uint8_t> to_ascii_buffer();
	Vector<uint8_t> to_utf8_buffer();
	Vector<uint8_t> to_utf16_buffer();
	Vector<uint8_t> to_utf32_buffer();

	String(const char *p_str);
	String(const wchar_t *p_str);
	String(const CharType *p_str);
	String(const char *p_str, int p_clip_to_len);
	String(const wchar_t *p_str, int p_clip_to_len);
	String(const CharType *p_str, int p_clip_to_len);
	String(const StrRange &p_range);

private:
	CowData<CharType> _cowdata;
	static const CharType _null;

	void copy_from(const char *p_cstr);
	void copy_from(const char *p_cstr, const int p_clip_to);
	void copy_from(const wchar_t *p_cstr);
	void copy_from(const wchar_t *p_cstr, const int p_clip_to);
	void copy_from(const CharType *p_cstr);
	void copy_from(const CharType *p_cstr, const int p_clip_to);

	void copy_from(const CharType &p_char);

	void copy_from_unchecked(const CharType *p_char, const int p_length);

	bool _base_is_subsequence_of(const String &p_string, bool case_insensitive);
	int _count(const String &p_string, int p_from, int p_to, bool p_case_insensitive);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

StringName
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class StringName {
	enum {
		STRING_TABLE_BITS = 14,
		STRING_TABLE_LEN = 1 << STRING_TABLE_BITS,
		STRING_TABLE_MASK = STRING_TABLE_LEN - 1
	};

	struct _Data {
		SafeRefCount refcount;
		SafeNumeric<uint32_t> static_count;
		const char *cname;
		String name;

#ifdef DEBUG_ENABLED
		uint32_t debug_references;
#endif

		String get_name();

		int idx;
		uint32_t hash;
		_Data *prev;
		_Data *next;

		_Data();
	};

	static _Data *_table[STRING_TABLE_LEN];

	_Data *_data;

	union _HashUnion {
		_Data *ptr;
		uint32_t hash;

		_HashUnion();
	};

	void unref();
	friend void register_core_types();
	friend void unregister_core_types();

	static Mutex lock;
	static bool configured;
#ifdef DEBUG_ENABLED
	struct DebugSortReferences {
		bool operator();
	};

	static bool debug_stringname;
#endif

	StringName(_Data *p_data);

public:
	operator const void *();

	bool operator==(const String &p_name);
	bool operator==(const char *p_name);
	bool operator!=(const String &p_name);

	bool is_node_unique_name();

	bool operator<(const StringName &p_name);
	bool operator==(const StringName &p_name);
	uint32_t hash();
	const void *data_unique_pointer();
	bool operator!=(const StringName &p_name);

	operator String();

	static StringName search(const char *p_name);
	static StringName search(const CharType *p_name);
	static StringName search(const String &p_name);

	struct AlphCompare {
		bool operator();
	};

	void operator=(const StringName &p_name);
	StringName(const char *p_name, bool p_static = false);
	StringName(const StringName &p_name);
	StringName(const String &p_name, bool p_static = false);
	StringName(const StaticCString &p_static_string, bool p_static = false);
	StringName();
	~StringName();

	static void setup();
	static void cleanup();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

PoolVector
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class PoolVector {
	MemoryPool::Alloc *alloc;

	void _copy_on_write();

	void _reference(const PoolVector &p_pool_vector);

	void _unreference();

public:
	class Access {
		friend class PoolVector;

	protected:
		MemoryPool::Alloc *alloc;
		T *mem;

		void _ref(MemoryPool::Alloc *p_alloc);

		void _unref();

		Access();

	public:
		virtual ~Access();

		void release();
	};

	class Read : public Access {
	public:
		const T &operator[](int p_index);
		const T *ptr();

		void operator=(const Read &p_read);

		Read(const Read &p_read);

		Read();
	};

	class Write : public Access {
	public:
		T &operator[](int p_index);
		T *ptr();

		void operator=(const Write &p_read);

		Write(const Write &p_read);

		Write();
	};

	Read read();
	Write write();

	template <class MC>
	void fill_with(const MC &p_mc);

	void remove(int p_index);

	int size();
	bool empty();
	T get(int p_index);
	void set(int p_index, const T &p_val);
	void fill(const T &p_val);
	void push_back(const T &p_val);
	void append(const T &p_val);
	void append_array(const PoolVector<T> &p_arr);

	PoolVector<T> subarray(int p_from, int p_to);

	Error insert(int p_pos, const T &p_val);

	String join(const String &delimiter);

	bool contains(const T &p_val);
	int find(const T &p_val, int p_from = 0);
	int rfind(const T &p_val, int p_from = -1);
	int count(const T &p_val);
	bool has(const T &p_val);

	bool is_locked();

	T operator[](int p_index);

	Error resize(int p_size);
	Error clear();

	void invert();
	void sort();

	void operator=(const PoolVector &p_pool_vector);
	PoolVector();
	PoolVector(const PoolVector &p_pool_vector);
	~PoolVector();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

TightLocalVector
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class TightLocalVector {
private:
	U count = 0;
	U capacity = 0;
	T *data = nullptr;

public:
	T *ptr();

	const T *ptr();

	void push_back(T p_elem);

	void remove(U p_index);

	void remove_unordered(U p_index);

	void erase(const T &p_val);

	U erase_multiple_unordered(const T &p_val);

	void invert();

	void clear();
	void reset();
	bool empty();
	U get_capacity();
	void reserve(U p_size);

	U size();
	void resize(U p_size);
	const T &operator[](U p_index);
	T &operator[](U p_index);

	void fill(T p_val);

	void insert(U p_pos, T p_val);

	int64_t find(const T &p_val, U p_from = 0);

	template <class C>
	void sort_custom();

	void sort();

	void ordered_insert(T p_val);

	operator Vector<T>();

	operator PoolVector<T>();

	Vector<uint8_t> to_byte_array();

	TightLocalVector();
	TightLocalVector(const TightLocalVector &p_from);
	TightLocalVector(const Vector<T> &p_from);
	TightLocalVector(const PoolVector<T> &p_from);

	void operator=(const TightLocalVector &p_from);
	void operator=(const Vector<T> &p_from);
	TightLocalVector &operator=(const PoolVector<T> &p_from);

	~TightLocalVector();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

TightLocalVectori
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class TightLocalVectori : public TightLocalVector<T, I, force_trivial> {
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

LocalVector
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class LocalVector {
protected:
	U count = 0;
	U capacity = 0;
	T *data = nullptr;

public:
	T *ptr();

	const T *ptr();

	void push_back(T p_elem);

	void remove(U p_index);

	void remove_unordered(U p_index);

	bool erase(const T &p_val);

	U erase_multiple_unordered(const T &p_val);

	void invert();

	void clear();
	void reset();
	bool empty();
	U get_capacity();
	void reserve(U p_size, bool p_allow_shrink = false);

	U size();
	void resize(U p_size);
	const T &operator[](U p_index);
	T &operator[](U p_index);

	void fill(T p_val);

	void insert(U p_pos, T p_val);

	int64_t find(const T &p_val, U p_from = 0);

	template <class C>
	void sort_custom();

	void sort();

	void ordered_insert(T p_val);

	operator Vector<T>();

	operator PoolVector<T>();

	Vector<uint8_t> to_byte_array();

	LocalVector();
	LocalVector(const LocalVector &p_from);
	LocalVector(const Vector<T> &p_from);
	LocalVector(const PoolVector<T> &p_from);

	LocalVector &operator=(const LocalVector &p_from);
	LocalVector &operator=(const Vector<T> &p_from);
	LocalVector &operator=(const PoolVector<T> &p_from);

	~LocalVector();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

LocalVectori
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class LocalVectori : public LocalVector<T, I, force_trivial> {
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

OGHashMap
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class OGHashMap {
public:
	struct Pair {
		TKey key;
		TData data;

		Pair(const TKey &p_key);
		Pair(const TKey &p_key, const TData &p_data);
	};

	struct Element {
	private:
		friend class OGHashMap;

		uint32_t hash;
		Element *next;
		Element();
		Pair pair;

	public:
		const TKey &key();

		TData &value();

		const TData &value();

		TData &get();
		const TData &get();

		Element(const TKey &p_key);
		Element(const Element &p_other);
	};

private:
	Element **hash_table;
	uint8_t hash_table_power;
	uint32_t elements;

	void make_hash_table();

	void erase_hash_table();

	void check_hash_table();

	const Element *get_element(const TKey &p_key);

	Element *create_element(const TKey &p_key);

	void copy_from(const OGHashMap &p_t);

public:
	Element *set(const TKey &p_key, const TData &p_data);

	Element *set(const Pair &p_pair);

	bool has(const TKey &p_key);

	const TData &get(const TKey &p_key);

	TData &get(const TKey &p_key);

	TData *getptr(const TKey &p_key);

	const TData *getptr(const TKey &p_key);

	const Element *find(const TKey &p_key);

	Element *find(const TKey &p_key);

	template <class C>
	TData *custom_getptr(C p_custom_key, uint32_t p_custom_hash);

	template <class C>
	const TData *custom_getptr(C p_custom_key, uint32_t p_custom_hash);

	bool erase(const TKey &p_key);

	const TData &operator[](const TKey &p_key);
	TData &operator[](const TKey &p_key);

	const TKey *next(const TKey *p_key);

	unsigned int size();

	bool empty();

	void clear();

	void operator=(const OGHashMap &p_table);

	OGHashMap();

	void get_key_value_ptr_array(const Pair **p_pairs);

	void get_key_list(List<TKey> *p_keys);

	OGHashMap(const OGHashMap &p_table);

	~OGHashMap();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

OrderedHashMap
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class OrderedHashMap {
	typedef List<Pair<const K *, V>> InternalList;
	typedef OGHashMap<K, typename InternalList::Element *, Hasher, Comparator, MIN_HASH_TABLE_POWER, RELATIONSHIP> InternalMap;

	InternalList list;
	InternalMap map;

public:
	class Element {
		friend class OrderedHashMap<K, V, Hasher, Comparator, MIN_HASH_TABLE_POWER, RELATIONSHIP>;

		typename InternalList::Element *list_element;
		typename InternalList::Element *prev_element;
		typename InternalList::Element *next_element;

		Element(typename InternalList::Element *p_element);

	public:
		Element();

		Element next();

		Element prev();

		Element(const Element &other);

		Element &operator=(const Element &other);

		bool operator==(const Element &p_other);
		bool operator!=(const Element &p_other);

		operator bool();

		const K &key();

		V &value();

		const V &value();

		V &get();

		const V &get();
	};

	class ConstElement {
		friend class OrderedHashMap<K, V, Hasher, Comparator, MIN_HASH_TABLE_POWER, RELATIONSHIP>;

		const typename InternalList::Element *list_element;

		ConstElement(const typename InternalList::Element *p_element);

	public:
		ConstElement();

		ConstElement(const ConstElement &other);

		ConstElement &operator=(const ConstElement &other);

		ConstElement next();

		ConstElement prev();

		bool operator==(const ConstElement &p_other);
		bool operator!=(const ConstElement &p_other);

		operator bool();

		const K &key();

		const V &value();

		const V &get();
	};

	ConstElement find(const K &p_key);

	Element find(const K &p_key);

	Element insert(const K &p_key, const V &p_value);

	void erase(Element &p_element);

	bool erase(const K &p_key);

	bool has(const K &p_key);

	const V &operator[](const K &p_key);

	V &operator[](const K &p_key);

	Element front();

	Element back();

	ConstElement front();

	ConstElement back();

	bool empty();
	int size();

	const void *id();

	void clear();

private:
	void _copy_from(const OrderedHashMap &p_map);

public:
	void operator=(const OrderedHashMap &p_map);

	OrderedHashMap(const OrderedHashMap &p_map);

	OrderedHashMap();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

HashMap
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class HashMap {
public:
	const uint32_t MIN_CAPACITY_INDEX = 2; 
	const float MAX_OCCUPANCY = 0.75;
	const uint32_t EMPTY_HASH = 0;

public:
	struct Element {
		Element *next = nullptr;
		Element *prev = nullptr;
		KeyValue<TKey, TValue> data;

		const TKey &key();

		TValue &value();

		const TValue &value();

		TValue &get();
		const TValue &get();

		Element();
		Element(const TKey &p_key, const TValue &p_value);
	};

public:
	uint32_t get_capacity();
	uint32_t size();

	bool empty();

	void clear();

	TValue &get(const TKey &p_key);

	const TValue &get(const TKey &p_key);

	const TValue *getptr(const TKey &p_key);

	TValue *getptr(const TKey &p_key);

	const Element *get_element(const TKey &p_key);

	Element *get_element(const TKey &p_key);

	const Element *find(const TKey &p_key);

	Element *find(const TKey &p_key);

	template <class C>
	TValue *custom_getptr(C p_custom_key, uint32_t p_custom_hash);

	template <class C>
	const TValue *custom_getptr(C p_custom_key, uint32_t p_custom_hash);

	bool has(const TKey &p_key);

	bool erase(const TKey &p_key);

	void reserve(uint32_t p_new_capacity);

	Element *front();
	Element *back();

	const Element *front();
	const Element *back();

	const TKey *next(const TKey *p_key);

	const TValue &operator[](const TKey &p_key);

	TValue &operator[](const TKey &p_key);

	Element *insert(const TKey &p_key, const TValue &p_value, bool p_front_insert = false);

	Element *set(const TKey &p_key, const TValue &p_value, bool p_front_insert = false);

	void get_key_list(List<TKey> *p_keys);

	HashMap(const HashMap &p_other);

	void operator=(const HashMap &p_other);

	HashMap(uint32_t p_initial_capacity);
	HashMap();

	uint32_t debug_get_hash(uint32_t p_index);
	Element *debug_get_element(uint32_t p_index);

	~HashMap();

private:
	Element **elements = nullptr;
	uint32_t *hashes = nullptr;
	Element *head_element = nullptr;
	Element *tail_element = nullptr;

	uint32_t capacity_index = 0;
	uint32_t num_elements = 0;

	uint32_t _hash(const TKey &p_key);

	static uint32_t _get_probe_length(const uint32_t p_pos, const uint32_t p_hash, const uint32_t p_capacity, const uint64_t p_capacity_inv);

	bool _lookup_pos(const TKey &p_key, uint32_t &r_pos);

	void _insert_with_hash(uint32_t p_hash, Element *p_value);

	void _resize_and_rehash(uint32_t p_new_capacity_index);

	Element *_insert(const TKey &p_key, const TValue &p_value, bool p_front_insert = false);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

HashSet
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class HashSet {
public:
	static constexpr uint32_t MIN_CAPACITY_INDEX = 2; 
	static constexpr float MAX_OCCUPANCY = 0.75;
	static constexpr uint32_t EMPTY_HASH = 0;

private:
	TKey *keys = nullptr;
	uint32_t *hash_to_key = nullptr;
	uint32_t *key_to_hash = nullptr;
	uint32_t *hashes = nullptr;

	uint32_t capacity_index = 0;
	uint32_t num_elements = 0;

	uint32_t _hash(const TKey &p_key);

	static uint32_t _get_probe_length(const uint32_t p_pos, const uint32_t p_hash, const uint32_t p_capacity, const uint64_t p_capacity_inv);

	bool _lookup_pos(const TKey &p_key, uint32_t &r_pos);

	uint32_t _insert_with_hash(uint32_t p_hash, uint32_t p_index);

	void _resize_and_rehash(uint32_t p_new_capacity_index);

	int32_t _insert(const TKey &p_key);

	void _init_from(const HashSet &p_other);

public:
	uint32_t get_capacity();
	uint32_t size();

	bool is_empty();

	void clear();

	bool has(const TKey &p_key);

	bool erase(const TKey &p_key);

	void reserve(uint32_t p_new_capacity);

	struct Iterator {
		const TKey &operator*();
		const TKey *operator->();
		Iterator &operator++();
		Iterator &operator--();

		const TKey &key();
		const TKey *key_ptr();

		Iterator &next();
		Iterator &prev();

		bool valid();

		bool operator==(const Iterator &b);
		bool operator!=(const Iterator &b);

		explicit operator bool();

		Iterator(const TKey *p_keys, uint32_t p_num_keys, int32_t p_index = -1);
		Iterator();
		Iterator(const Iterator &p_it);
		void operator=(const Iterator &p_it);

	private:
		const TKey *keys = nullptr;
		uint32_t num_keys = 0;
		int32_t index = -1;
	};

	Iterator begin();
	Iterator end();
	Iterator last();

	Iterator find(const TKey &p_key);

	void remove(const Iterator &p_iter);

	Iterator insert(const TKey &p_key);

	HashSet(const HashSet &p_other);

	void operator=(const HashSet &p_other);

	HashSet(uint32_t p_initial_capacity);
	HashSet();

	void reset();

	~HashSet();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

FileAccess
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class FileAccess {
public:
	
	String read_file(const String &path);

	Vector<uint8_t> read_file_bin(const String &path);
	Error read_file_into_bin(const String &path, Vector<uint8_t> *data);

	Error write_file(const String &path, const String &str);
	Error write_file_bin(const String &path, const Vector<uint8_t> &data);

	FileAccess();
	virtual ~FileAccess();

private:
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

DirAccess
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class DirAccess {
public:
	Error open_dir(const String &path, bool skip_specials = true);
	Error open_dir(const char *path, bool skip_specials = true);
	void close_dir();

	bool has_next();
	bool read();
	bool next();

	bool current_is_ok();
	String current_get_name();
	String current_get_path();
	String current_get_extension();
	const char *current_get_name_cstr();
	const char *current_get_path_cstr();
	const char *current_get_extension_cstr();
	bool current_is_file();
	bool current_is_dir();
	bool current_is_special_dir();

	bool is_dir_open();
	bool is_dir_closed();

	DirAccess();
	virtual ~DirAccess();

private:
	bool _skip_specials;
	int _read_file_result;
	tinydir_dir *_dir;
	tinydir_file *_file;

	bool _dir_open;
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SFWCore
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class SFWCore {
public:
	static void setup();
	static void cleanup();

protected:
	static bool _initialized;
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

RefPtr
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class RefPtr {
	enum {
		DATASIZE = sizeof(void *);
	RefPtr(const RefPtr &p_other);
	RefPtr();
	~RefPtr();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

CoreStringNames
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class CoreStringNames {
public:
	static void create();
	static void free();

	CoreStringNames();

	static CoreStringNames *get_singleton();

	static CoreStringNames *singleton;

	StringName _free;
	StringName changed;
	StringName _meta;
	StringName _script;
	StringName script_changed;
	StringName ___pdcdata;
	StringName __getvar;
	StringName _iter_init;
	StringName _iter_next;
	StringName _iter_get;
	StringName get_rid;
	StringName _to_string;
#ifdef TOOLS_ENABLED
	StringName _sections_unfolded;
#endif
	StringName _custom_features;

	StringName x;
	StringName y;
	StringName z;
	StringName w;
	StringName r;
	StringName g;
	StringName b;
	StringName a;
	StringName position;
	StringName size;
	StringName end;
	StringName basis;
	StringName origin;
	StringName normal;
	StringName d;
	StringName h;
	StringName s;
	StringName v;
	StringName r8;
	StringName g8;
	StringName b8;
	StringName a8;
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Array
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class Array {
	mutable ArrayPrivate *_p;
	void _ref(const Array &p_from);
	void _unref();

	int _clamp_slice_index(int p_index);

public:
	Variant &operator[](int p_idx);
	const Variant &operator[](int p_idx);

	void set(int p_idx, const Variant &p_value);
	const Variant &get(int p_idx);

	int size();
	bool empty();
	void clear();

	bool deep_equal(const Array &p_array, int p_recursion_count = 0);
	bool operator==(const Array &p_array);

	uint32_t hash();
	uint32_t recursive_hash(int p_recursion_count);
	void operator=(const Array &p_array);

	void push_back(const Variant &p_value);
	void append(const Variant &p_value);
	void append_array(const Array &p_array);
	Error resize(int p_new_size);

	void insert(int p_pos, const Variant &p_value);
	void remove(int p_pos);
	void fill(const Variant &p_value);

	Variant front();
	Variant back();

	Array &sort();
	Array &sort_custom(Object *p_obj);
	void shuffle();
	int bsearch(const Variant &p_value, bool p_before = true);
	int bsearch_custom(const Variant &p_value, Object *p_obj, const StringName &p_function, bool p_before = true);
	Array &invert();

	int find(const Variant &p_value, int p_from = 0);
	int rfind(const Variant &p_value, int p_from = -1);
	int find_last(const Variant &p_value);
	int count(const Variant &p_value);
	bool has(const Variant &p_value);

	void erase(const Variant &p_value);

	void push_front(const Variant &p_value);
	Variant pop_back();
	Variant pop_front();
	Variant pop_at(int p_pos);

	Array duplicate(bool p_deep = false);

	Array slice(int p_begin, int p_end, int p_step = 1, bool p_deep = false);

	Variant min();
	Variant max();

	const void *id();

	String sprintf(const String &p_format, bool *error);

	Array(const Array &p_from);
	Array();
	~Array();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Dictionary
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class Dictionary {
	mutable DictionaryPrivate *_p;

	void _ref(const Dictionary &p_from);
	void _unref();

public:
	void get_key_list(List<Variant> *p_keys);
	Variant get_key_at_index(int p_index);
	Variant get_value_at_index(int p_index);

	Variant &operator[](const Variant &p_key);
	const Variant &operator[](const Variant &p_key);

	const Variant *getptr(const Variant &p_key);
	Variant *getptr(const Variant &p_key);

	Variant get_valid(const Variant &p_key);
	Variant get(const Variant &p_key, const Variant &p_default);

	int size();
	bool empty();
	void clear();
	void merge(const Dictionary &p_dictionary, bool p_overwrite = false);

	bool has(const Variant &p_key);
	bool has_all(const Array &p_keys);
	Variant find_key(const Variant &p_value);

	bool erase(const Variant &p_key);

	bool deep_equal(const Dictionary &p_dictionary, int p_recursion_count = 0);
	bool operator==(const Dictionary &p_dictionary);
	bool operator!=(const Dictionary &p_dictionary);

	uint32_t hash();
	uint32_t recursive_hash(int p_recursion_count);
	void operator=(const Dictionary &p_dictionary);

	const Variant *next(const Variant *p_key = nullptr);

	Array keys();
	Array values();

	Dictionary duplicate(bool p_deep = false);

	const void *id();

	Dictionary(const Dictionary &p_from);
	Dictionary();
	~Dictionary();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Variant
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class Variant {
public:
	
	enum Type {

		NIL,

		BOOL,
		INT,
		REAL,
		STRING,

		RECT2,
		RECT2I,
		VECTOR2,
		VECTOR2I,
		VECTOR3,
		VECTOR3I,
		VECTOR4,
		VECTOR4I,

		PLANE,
		QUATERNION,
		AABB,
		BASIS,
		TRANSFORM,
		TRANSFORM2D,
		PROJECTION,

		COLOR,
		OBJECT,
		STRING_NAME,
		DICTIONARY,
		ARRAY,

		POOL_BYTE_ARRAY,
		POOL_INT_ARRAY,
		POOL_REAL_ARRAY,
		POOL_STRING_ARRAY,
		POOL_VECTOR2_ARRAY,
		POOL_VECTOR2I_ARRAY,
		POOL_VECTOR3_ARRAY,
		POOL_VECTOR3I_ARRAY,
		POOL_VECTOR4_ARRAY,
		POOL_VECTOR4I_ARRAY,
		POOL_COLOR_ARRAY,

		VARIANT_MAX 

	};

	enum {
		
		MAX_RECURSION_DEPTH = 1024,
	};

private:
	
	Type type;

	struct ObjData {
		
		ObjectRC *rc;
		
		RefPtr ref;
	};

	ObjData &_get_obj();
	const ObjData &_get_obj();

	union {
		bool _bool;
		int64_t _int;
		double _real;
		Transform2D *_transform2d;
		::AABB *_aabb;
		Basis *_basis;
		Transform *_transform;
		Projection *_projection;
		void *_ptr; 
		uint8_t _mem[sizeof(ObjData);
	} _data GCC_ALIGNED_8;

	void reference(const Variant &p_variant);
	void clear();

public:
	Type get_type();
	static String get_type_name(Variant::Type p_type);
	static bool can_convert(Type p_type_from, Type p_type_to);
	static bool can_convert_strict(Type p_type_from, Type p_type_to);

	bool is_ref();
	bool is_num();
	bool is_array();
	bool is_null();
	bool is_shared();
	bool is_zero();
	bool is_one();

	ObjectID get_object_instance_id();
	bool is_invalid_object();

	operator bool();
	operator signed int();
	operator unsigned int();
	operator signed short();
	operator unsigned short();
	operator signed char();
	operator unsigned char();
	
	operator int64_t();
	operator uint64_t();
#ifdef NEED_LONG_INT
	operator signed long();
	operator unsigned long();
#endif

	operator CharType();
	operator float();
	operator double();
	operator String();
	operator StringName();
	operator Rect2();
	operator Rect2i();
	operator Vector2();
	operator Vector2i();
	operator Vector3();
	operator Vector3i();
	operator Vector4();
	operator Vector4i();
	operator Plane();
	operator ::AABB();
	operator Quaternion();
	operator Basis();
	operator Transform();
	operator Transform2D();
	operator Projection();

	operator Color();
	operator RefPtr();

	operator Object *();

	operator Dictionary();
	operator Array();

	operator PoolVector<uint8_t>();
	operator PoolVector<int>();
	operator PoolVector<real_t>();
	operator PoolVector<String>();
	operator PoolVector<Vector2>();
	operator PoolVector<Vector2i>();
	operator PoolVector<Vector3>();
	operator PoolVector<Vector3i>();
	operator PoolVector<Vector4>();
	operator PoolVector<Vector4i>();
	operator PoolVector<Color>();
	operator PoolVector<Plane>();
	operator PoolVector<Face3>();

	operator Vector<Variant>();
	operator Vector<uint8_t>();
	operator Vector<int>();
	operator Vector<real_t>();
	operator Vector<String>();
	operator Vector<StringName>();
	operator Vector<Vector3>();
	operator Vector<Vector3i>();
	operator Vector<Vector4>();
	operator Vector<Vector4i>();
	operator Vector<Color>();
	operator Vector<Vector2>();
	operator Vector<Vector2i>();

	operator Vector<Plane>();

	operator Margin();
	operator Side();
	operator Orientation();

	Variant(bool p_bool);
	Variant(signed int p_int);
	Variant(unsigned int p_int);
#ifdef NEED_LONG_INT
	Variant(signed long p_long);
	Variant(unsigned long p_long);
#endif
	Variant(signed short p_short);
	Variant(unsigned short p_short);
	Variant(signed char p_char);
	Variant(unsigned char p_char);
	Variant(int64_t p_int);
	Variant(uint64_t p_int);
	Variant(float p_float);
	Variant(double p_double);
	Variant(const String &p_string);
	Variant(const StringName &p_string);
	Variant(const char *const p_cstring);
	Variant(const CharType *p_wstring);
	Variant(const Vector2 &p_vector2);
	Variant(const Vector2i &p_vector2);
	Variant(const Rect2 &p_rect2);
	Variant(const Rect2i &p_rect2);
	Variant(const Vector3 &p_vector3);
	Variant(const Vector3i &p_vector3);
	Variant(const Vector4 &p_vector4);
	Variant(const Vector4i &p_vector4);
	Variant(const Projection &p_projection);
	Variant(const Plane &p_plane);
	Variant(const ::AABB &p_aabb);
	Variant(const Quaternion &p_quat);
	Variant(const Basis &p_matrix);
	Variant(const Transform2D &p_transform);
	Variant(const Transform &p_transform);
	Variant(const Color &p_color);
	Variant(const RefPtr &p_resource);
	Variant(const Object *p_object);
	Variant(const Dictionary &p_dictionary);

	Variant(const Array &p_array);
	Variant(const PoolVector<Plane> &p_array);
	Variant(const PoolVector<uint8_t> &p_raw_array);
	Variant(const PoolVector<int> &p_int_array);
	Variant(const PoolVector<real_t> &p_real_array);
	Variant(const PoolVector<String> &p_string_array);
	Variant(const PoolVector<Vector3> &p_vector3_array);
	Variant(const PoolVector<Vector3i> &p_vector3_array);
	Variant(const PoolVector<Color> &p_color_array);
	Variant(const PoolVector<Face3> &p_face_array);
	Variant(const PoolVector<Vector2> &p_vector2_array);
	Variant(const PoolVector<Vector2i> &p_vector2_array);
	Variant(const PoolVector<Vector4> &p_vector4_array);
	Variant(const PoolVector<Vector4i> &p_vector4_array);

	Variant(const Vector<Variant> &p_array);
	Variant(const Vector<uint8_t> &p_array);
	Variant(const Vector<int> &p_array);
	Variant(const Vector<real_t> &p_array);
	Variant(const Vector<String> &p_array);
	Variant(const Vector<StringName> &p_array);
	Variant(const Vector<Vector3> &p_array);
	Variant(const Vector<Vector3i> &p_array);
	Variant(const Vector<Color> &p_array);
	Variant(const Vector<Plane> &p_array);
	Variant(const Vector<Vector2> &p_array);
	Variant(const Vector<Vector2i> &p_array);
	Variant(const Vector<Vector4> &p_array);
	Variant(const Vector<Vector4i> &p_array);

	enum Operator {
		
		OP_EQUAL,
		OP_NOT_EQUAL,
		OP_LESS,
		OP_LESS_EQUAL,
		OP_GREATER,
		OP_GREATER_EQUAL,
		
		OP_ADD,
		OP_SUBTRACT,
		OP_MULTIPLY,
		OP_DIVIDE,
		OP_NEGATE,
		OP_POSITIVE,
		OP_MODULE,
		OP_STRING_CONCAT,
		
		OP_SHIFT_LEFT,
		OP_SHIFT_RIGHT,
		OP_BIT_AND,
		OP_BIT_OR,
		OP_BIT_XOR,
		OP_BIT_NEGATE,
		
		OP_AND,
		OP_OR,
		OP_XOR,
		OP_NOT,
		
		OP_IN,
		OP_MAX
	};

	static String get_operator_name(Operator p_op);
	static void evaluate(const Operator &p_op, const Variant &p_a, const Variant &p_b, Variant &r_ret, bool &r_valid);
	static Variant evaluate(const Operator &p_op, const Variant &p_a, const Variant &p_b);

	void zero();
	Variant duplicate(bool deep = false);
	static void blend(const Variant &a, const Variant &b, float c, Variant &r_dst);
	static void interpolate(const Variant &a, const Variant &b, float c, Variant &r_dst);
	static void sub(const Variant &a, const Variant &b, Variant &r_dst);

	void set_named(const StringName &p_index, const Variant &p_value, bool *r_valid = nullptr);
	Variant get_named(const StringName &p_index, bool *r_valid = nullptr);

	void set(const Variant &p_index, const Variant &p_value, bool *r_valid = nullptr);
	Variant get(const Variant &p_index, bool *r_valid = nullptr);
	bool in(const Variant &p_index, bool *r_valid = nullptr);

	bool iter_init(Variant &r_iter, bool &r_valid);
	bool iter_next(Variant &r_iter, bool &r_valid);
	Variant iter_get(const Variant &r_iter, bool &r_valid);

	bool deep_equal(const Variant &p_variant, int p_recursion_count = 0);
	bool operator==(const Variant &p_variant);
	bool operator!=(const Variant &p_variant);
	bool operator<(const Variant &p_variant);
	uint32_t hash();
	uint32_t recursive_hash(int p_recursion_count);

	bool hash_compare(const Variant &p_variant);
	bool booleanize();
	String stringify(List<const void *> &stack);

	void operator=(const Variant &p_variant);
	Variant(const Variant &p_variant);
	Variant();
	~Variant();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Signal
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class Signal {
public:
	Object *emitter;
	Vector<Variant> params;
	Vector<Variant> static_data;

	template <class T>
	void connect(T *obj, void (*func);
	template <class T>
	void disconnect(T *obj, void (*func);
	template <class T>
	bool is_connected(T *obj, void (*func);

	void connect_static(void (*func);
	void disconnect_static(void (*func);
	bool is_connected_static(void (*func);

	void emit(Object *p_emitter);
	void emit(Object *p_emitter, const Variant &p1);
	void emit(Object *p_emitter, const Variant &p1, const Variant &p2);
	void emit(Object *p_emitter, const Variant &p1, const Variant &p2, const Variant &p3);
	void emit(Object *p_emitter, const Variant &p1, const Variant &p2, const Variant &p3, const Variant &p4);
	void emit(Object *p_emitter, const Variant &p1, const Variant &p2, const Variant &p3, const Variant &p4, const Variant &p5);

	Signal();
	~Signal();

protected:
	enum SignalEntryType {
		SIGNAL_ENTRY_TYPE_NONE = 0,
		SIGNAL_ENTRY_TYPE_STATIC = 1,
		SIGNAL_ENTRY_TYPE_CLASS = 2,
	};

	struct SignalEntry {
		SignalEntryType type;

		virtual void call(Signal *s);

		SignalEntry();
	};

	struct StaticSignalEntry : public SignalEntry {
		void (*func);

		virtual void call(Signal *s);

		StaticSignalEntry();
	};

	struct ClassSignalEntry : public SignalEntry {

		virtual void* get_obj_ptr();

		virtual void* get_func_ptr();

		ClassSignalEntry();
	};

	template<typename T>
	struct ClassSignalEntrySpec : public ClassSignalEntry {
		union {
			T* obj;
			void* obj_ptr;
		};
		union {
			void (*func);
			void* func_ptr;
		};

		virtual void call(Signal *s);

		void* get_obj_ptr();

		void* get_func_ptr();

		ClassSignalEntrySpec();
	};

protected:
	Vector<SignalEntry *> entries;
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Object
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class Object {
public:
	enum {
		NOTIFICATION_POSTINITIALIZE = 0,
		NOTIFICATION_PREDELETE = 1
	};

	void set(const StringName &p_name, const Variant &p_value, bool *r_valid = nullptr);
	Variant get(const StringName &p_name, bool *r_valid = nullptr);

	virtual bool lt(const Variant &p_value_l, const Variant &p_value_r);

	virtual String get_class();
	static void *get_class_ptr_static();

	static String get_class_static();
	static String get_parent_class_static();

	static void get_inheritance_list_static(Vector<String> *p_inheritance_list);

	virtual bool is_class(const String &p_class);
	virtual bool is_class_ptr(void *p_ptr);

	static void get_valid_parents_static(Vector<String> *p_parents);
	static void _get_valid_parents_static(Vector<String> *p_parents);

	virtual const StringName *_get_class_namev();

	const StringName &get_class_name();

	ObjectRC *_use_rc();

	ObjectID get_instance_id();

	void notification(int p_notification, bool p_reversed = false);
	virtual String to_string();

	bool _is_queued_for_deletion;
	bool is_queued_for_deletion();

	void cancel_free();

	bool has_meta(const String &p_name);
	void set_meta(const String &p_name, const Variant &p_value);
	void remove_meta(const String &p_name);
	Variant get_meta(const String &p_name, const Variant &p_default = Variant();
	void get_meta_list(List<String> *p_list);

	Object();
	virtual ~Object();

	template <class T>
	static T *cast_to(Object *p_object);

	template <class T>
	static const T *cast_to(const Object *p_object);

protected:
	void (Object::*_get_notification();

	bool _set(const StringName &p_name, const Variant &p_property);
	bool _get(const StringName &p_name, Variant &r_property);

	virtual bool _setv(const StringName &p_name, const Variant &p_property);
	virtual bool _getv(const StringName &p_name, Variant &r_property);

	bool (Object::*_get_get();
	bool (Object::*_get_set();

	virtual void _notificationv(int p_notification, bool p_reversed);
	void _notification(int p_notification);

	friend bool predelete_handler(Object *);
	friend void postinitialize_handler(Object *);

	int _predelete_ok;
	bool _predelete();
	void _postinitialize();

	mutable StringName _class_name;
	mutable const StringName *_class_ptr;

	ObjectID _instance_id;
	std::atomic<ObjectRC *> _rc;

	Dictionary metadata;
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ObjectDB
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class ObjectDB {
	struct ObjectPtrHash {
		static uint32_t hash(const Object *p_obj);
	};

	static HashMap<ObjectID, Object *> instances;
	static HashMap<Object *, ObjectID, ObjectPtrHash> instance_checks;

	static ObjectID instance_counter;
	friend class Object;
	friend void unregister_core_types();

	static RWLock rw_lock;
	static void cleanup();
	static ObjectID add_instance(Object *p_object);
	static void remove_instance(Object *p_object);
	friend void register_core_types();

public:
	typedef void (*DebugFunc);

	static Object *get_instance(ObjectID p_instance_id);
	static void debug_objects(DebugFunc p_func);
	static int get_object_count();

	static bool instance_validate(Object *p_ptr);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ObjectRC
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class ObjectRC {
	std::atomic<Object *> _ptr;
	std::atomic<uint32_t> _users;

public:
	
	const ObjectID instance_id;

	void increment();

	bool decrement();

	bool invalidate();

	Object *get_ptr();

	ObjectRC(Object *p_object);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Reference
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class Reference : public Object {
	SFW_OBJECT(Reference, Object);

public:
	bool is_referenced();
	bool init_ref();
	bool reference();
	bool unreference();
	int reference_get_count();

	Reference();
	virtual ~Reference();

private:
	SafeRefCount refcount;
	SafeRefCount refcount_init;
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Ref
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class Ref {
	T *reference;

	void ref(const Ref &p_from);

	void ref_pointer(T *p_ref);

public:
	bool operator==(const T *p_ptr);
	bool operator!=(const T *p_ptr);

	bool operator<(const Ref<T> &p_r);
	bool operator==(const Ref<T> &p_r);
	bool operator!=(const Ref<T> &p_r);

	T *operator->();

	T *operator*();

	const T *operator->();

	const T *ptr();
	T *ptr();

	const T *operator*();

	void operator=(const Ref &p_from);

	template <class T_Other>
	void operator=(const Ref<T_Other> &p_from);

	template <class T_Other>
	void reference_ptr(T_Other *p_ptr);

	Ref(const Ref &p_from);

	template <class T_Other>
	Ref(const Ref<T_Other> &p_from);

	Ref(T *p_reference);

	bool is_valid();
	bool is_null();

	void unref();

	void instance();

	RefPtr get_ref_ptr();

	operator Variant();

	void operator=(const RefPtr &p_refptr);

	void operator=(const Variant &p_variant);

	Ref(const Variant &p_variant);

	Ref(const RefPtr &p_refptr);

	Ref();

	~Ref();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Resource
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class Resource : public Reference {
	SFW_OBJECT(Resource, Reference);

public:
	Signal changed;

	void emit_changed();

	virtual Error load(const String &path);
	virtual Error save(const String &path);

	Resource();
	virtual ~Resource();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

RenderState
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class RenderState {
public:
	static Transform camera_transform_3d;
	static Transform model_view_matrix_3d;
	static Projection projection_matrix_3d;

	static Transform2D model_view_matrix_2d;
	static Transform projection_matrix_2d;

};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Image
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class Image : public Reference {
	SFW_OBJECT(Image, Reference);

public:
	enum {
		MAX_WIDTH = 16384, 
		MAX_HEIGHT = 16384 
	};

	enum Format {

		FORMAT_L8, 
		FORMAT_LA8, 
		FORMAT_R8,
		FORMAT_RG8,
		FORMAT_RGB8,
		FORMAT_RGBA8,
		FORMAT_RGBA4444,
		FORMAT_RGBA5551,
		FORMAT_RF, 
		FORMAT_RGF,
		FORMAT_RGBF,
		FORMAT_RGBAF,
		FORMAT_MAX
	};

	static const char *format_names[FORMAT_MAX];
	enum Interpolation {

		INTERPOLATE_NEAREST,
		INTERPOLATE_BILINEAR,
		INTERPOLATE_CUBIC,
		INTERPOLATE_TRILINEAR,
		INTERPOLATE_LANCZOS,
		
	};

	bool write_lock;

private:
	void _create_empty(int p_width, int p_height, bool p_use_mipmaps, Format p_format);

	void _create_from_data(int p_width, int p_height, bool p_use_mipmaps, Format p_format, const Vector<uint8_t> &p_data);

	Format format;
	Vector<uint8_t> data;
	int width, height;
	bool mipmaps;

	void _copy_internals_from(const Image &p_image);

	void _get_mipmap_offset_and_size(int p_mipmap, int &r_offset, int &r_width, int &r_height);

	static int _get_dst_image_size(int p_width, int p_height, Format p_format, int &r_mipmaps, int p_mipmaps = -1);
	bool _can_modify(Format p_format);

	void _put_pixelb(int p_x, int p_y, uint32_t p_pixel_size, uint8_t *p_data, const uint8_t *p_pixel);
	void _get_pixelb(int p_x, int p_y, uint32_t p_pixel_size, const uint8_t *p_data, uint8_t *p_pixel);

	void _repeat_pixel_over_subsequent_memory(uint8_t *p_pixel, int p_pixel_size, int p_count);

	static void average_4_uint8(uint8_t &p_out, const uint8_t &p_a, const uint8_t &p_b, const uint8_t &p_c, const uint8_t &p_d);
	static void average_4_float(float &p_out, const float &p_a, const float &p_b, const float &p_c, const float &p_d);
	static void average_4_half(uint16_t &p_out, const uint16_t &p_a, const uint16_t &p_b, const uint16_t &p_c, const uint16_t &p_d);
	static void average_4_rgbe9995(uint32_t &p_out, const uint32_t &p_a, const uint32_t &p_b, const uint32_t &p_c, const uint32_t &p_d);
	static void renormalize_uint8(uint8_t *p_rgb);
	static void renormalize_float(float *p_rgb);
	static void renormalize_half(uint16_t *p_rgb);
	static void renormalize_rgbe9995(uint32_t *p_rgb);

public:
	int get_width();
	int get_height();
	Vector2 get_size();
	bool has_mipmaps();
	int get_mipmap_count();

	void convert(Format p_new_format);

	Format get_format();

	int get_mipmap_offset(int p_mipmap);
	void get_mipmap_offset_and_size(int p_mipmap, int &r_ofs, int &r_size);
	void get_mipmap_offset_size_and_dimensions(int p_mipmap, int &r_ofs, int &r_size, int &w, int &h);

	void resize_to_po2(bool p_square = false, Interpolation p_interpolation = INTERPOLATE_BILINEAR);
	void resize(int p_width, int p_height, Interpolation p_interpolation = INTERPOLATE_BILINEAR);
	void shrink_x2();
	bool is_size_po2();
	
	void crop_from_point(int p_x, int p_y, int p_width, int p_height);
	void crop(int p_width, int p_height);

	void flip_x();
	void flip_y();

	int generate_mipmaps(bool p_renormalize = false);

	void clear_mipmaps();
	void normalize();

	void load_from_file(const String &file_name, Format p_format = FORMAT_RGBA8);

	void create(int p_width, int p_height, bool p_use_mipmaps, Format p_format);
	void create(int p_width, int p_height, bool p_use_mipmaps, Format p_format, const Vector<uint8_t> &p_data);

	void create(const char **p_xpm);

	bool empty();

	Vector<uint8_t> get_data();
	const uint8_t *datar();
	uint8_t *dataw();
	int get_data_size();

	Image();
	Image(int p_width, int p_height, bool p_use_mipmaps, Format p_format);
	Image(int p_width, int p_height, bool p_mipmaps, Format p_format, const Vector<uint8_t> &p_data);

	enum AlphaMode {
		ALPHA_NONE,
		ALPHA_BIT,
		ALPHA_BLEND
	};

	AlphaMode detect_alpha();
	bool is_invisible();

	static int get_format_pixel_size(Format p_format);
	static int get_format_pixel_rshift(Format p_format);
	static int get_format_block_size(Format p_format);
	static void get_format_min_pixel_size(Format p_format, int &r_w, int &r_h);

	static int get_image_data_size(int p_width, int p_height, Format p_format, bool p_mipmaps = false);
	static int get_image_required_mipmaps(int p_width, int p_height, Format p_format);
	static int get_image_mipmap_offset(int p_width, int p_height, Format p_format, int p_mipmap);

	enum CompressMode {
		COMPRESS_S3TC,
		COMPRESS_PVRTC2,
		COMPRESS_PVRTC4,
		COMPRESS_ETC,
		COMPRESS_ETC2,
		COMPRESS_BPTC,
		COMPRESS_MAX,
	};

	bool is_compressed();

	void fix_alpha_edges();
	void premultiply_alpha();
	void srgb_to_linear();
	void normalmap_to_xy();
	Ref<Image> rgbe_to_srgb();
	void bumpmap_to_normalmap(float bump_scale = 1.0);

	void blit_rect(const Ref<Image> &p_src, const Rect2 &p_src_rect, const Vector2 &p_dest);
	void blit_rect_mask(const Ref<Image> &p_src, const Ref<Image> &p_mask, const Rect2 &p_src_rect, const Vector2 &p_dest);
	void blend_rect(const Ref<Image> &p_src, const Rect2 &p_src_rect, const Vector2 &p_dest);
	void blend_rect_mask(const Ref<Image> &p_src, const Ref<Image> &p_mask, const Rect2 &p_src_rect, const Vector2 &p_dest);
	void fill(const Color &p_color);
	void fill_rect(const Rect2 &p_rect, const Color &p_color);

	Rect2 get_used_rect();
	Ref<Image> get_rect(const Rect2 &p_area);

	static String get_format_name(Format p_format);

	Image(const char **p_xpm);

	Ref<Image> duplicate();

	void lock();
	void unlock();

	enum DetectChannels {
		DETECTED_L,
		DETECTED_LA,
		DETECTED_R,
		DETECTED_RG,
		DETECTED_RGB,
		DETECTED_RGBA,
	};

	DetectChannels get_detected_channels();
	void optimize_channels();

	Color get_pixelv(const Vector2 &p_src);
	Color get_pixel(int p_x, int p_y);
	void set_pixelv(const Vector2 &p_dst, const Color &p_color);
	void set_pixel(int p_x, int p_y, const Color &p_color);

	void copy_internals_from(const Ref<Image> &p_image);

	~Image();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Texture
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class Texture : public Resource {
	SFW_OBJECT(Texture, Resource);

public:
	enum TextureFlags {
		TEXTURE_FLAG_FILTER = 1 << 0,
		TEXTURE_FLAG_REPEAT = 1 << 1,
		TEXTURE_FLAG_MIRRORED_REPEAT = 1 << 2,
		TEXTURE_FLAG_MIP_MAPS = 1 << 3,
	};

	uint32_t get_gl_texture();

	void create_from_image(const Ref<Image> &img);

	Ref<Image> get_data();

	Vector2i get_size();

	void upload();

	Texture();
	virtual ~Texture();

protected:
	void _get_gl_format(Image::Format p_format, uint32_t &r_gl_format, uint32_t &r_gl_internal_format, uint32_t &r_gl_type, bool &r_supported);

	Ref<Image> _image;

	int _texture_width;
	int _texture_height;
	Image::Format _texture_format;

	int _flags;
	int _texture_index;
	int _data_size;
	int _mipmaps;

	uint32_t _texture;
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

RenderTexture
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class RenderTexture : public Texture {
public:
	void set_as_render_target();
	void unset_render_target();

	RenderTexture();
	virtual ~RenderTexture();

protected:
	int _fbo_width;
	int _fbo_height;
	uint32_t _fbo;
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Mesh
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class Mesh : public Resource {
	SFW_OBJECT(Mesh, Resource);

public:
	void add_vertex2(float x, float y);
	void add_vertex3(float x, float y, float z);

	void add_normal(float x, float y, float z);
	void add_color(float r = 1, float g = 1, float b = 1, float a = 1);
    void add_color(const Color &p_color);

	void add_uv(float u, float v);

	void add_index(uint32_t index);
	void add_triangle(uint32_t i1, uint32_t i2, uint32_t i3);

	void clear();

	void upload();
	void destroy();
	void render();

	Mesh();
	Mesh(int vert_dim);
	virtual ~Mesh();

	uint32_t VBO;
	uint32_t IBO;

	int vertex_dimesions;

	Vector<float> vertices;
	Vector<float> normals;
	Vector<float> colors;
	Vector<float> uvs;
	Vector<uint32_t> indices;

protected:
	uint32_t vertices_vbo_size;
	uint32_t normals_vbo_size;
	uint32_t colors_vbo_size;
	uint32_t uvs_vbo_size;
	uint32_t indices_vbo_size;
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

MeshUtils
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class MeshUtils {
public:
    static void create_cone(Ref<Mesh> mesh);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

InputEvent
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class InputEvent : public Resource {
	SFW_OBJECT(InputEvent, Resource);

	int device;

protected:
	bool canceled;
	bool pressed;

public:
	static const int DEVICE_ID_TOUCH_MOUSE;
	static const int DEVICE_ID_INTERNAL;

	void set_device(int p_device);
	int get_device();

	bool is_action(const StringName &p_action, bool p_exact_match = false);
	bool is_action_pressed(const StringName &p_action, bool p_allow_echo = false, bool p_exact_match = false);
	bool is_action_released(const StringName &p_action, bool p_exact_match = false);
	float get_action_strength(const StringName &p_action, bool p_exact_match = false);
	float get_action_raw_strength(const StringName &p_action, bool p_exact_match = false);

	bool is_canceled();
	bool is_pressed();
	bool is_released();
	virtual bool is_echo();
	
	virtual String as_text();

	virtual Ref<InputEvent> xformed_by(const Transform2D &p_xform, const Vector2 &p_local_ofs = Vector2();

	virtual bool action_match(const Ref<InputEvent> &p_event, bool p_exact_match, bool *p_pressed, float *p_strength, float *p_raw_strength, float p_deadzone);
	virtual bool shortcut_match(const Ref<InputEvent> &p_event, bool p_exact_match = true);
	virtual bool is_action_type();

	virtual bool accumulate(const Ref<InputEvent> &p_event);
	InputEvent();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

InputEventWithModifiers
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class InputEventWithModifiers : public InputEvent {
	SFW_OBJECT(InputEventWithModifiers, InputEvent);

	bool shift;
	bool alt;
#ifdef APPLE_STYLE_KEYS
	union {
		bool command;
		bool meta; 
	};

	bool control;
#else
	union {
		bool command; 
		bool control;
	};
	bool meta; 

#endif

public:
	void set_shift(bool p_enabled);
	bool get_shift();

	void set_alt(bool p_enabled);
	bool get_alt();

	void set_control(bool p_enabled);
	bool get_control();

	void set_metakey(bool p_enabled);
	bool get_metakey();

	void set_command(bool p_enabled);
	bool get_command();

	void set_modifiers_from_event(const InputEventWithModifiers *event);

	uint32_t get_modifiers_mask();

	InputEventWithModifiers();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

InputEventKey
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class InputEventKey : public InputEventWithModifiers {
	SFW_OBJECT(InputEventKey, InputEventWithModifiers);

	uint32_t scancode; 
	uint32_t physical_scancode;
	uint32_t unicode; 

	bool echo; 

	bool action_match_force_exact;

public:
	void set_pressed(bool p_pressed);

	void set_scancode(uint32_t p_scancode);
	uint32_t get_scancode();

	void set_physical_scancode(uint32_t p_scancode);
	uint32_t get_physical_scancode();

	void set_unicode(uint32_t p_unicode);
	uint32_t get_unicode();

	void set_echo(bool p_enable);
	virtual bool is_echo();

	void set_action_match_force_exact(bool p_enable);
	bool is_action_match_force_exact();

	uint32_t get_scancode_with_modifiers();
	uint32_t get_physical_scancode_with_modifiers();

	virtual bool action_match(const Ref<InputEvent> &p_event, bool p_exact_match, bool *p_pressed, float *p_strength, float *p_raw_strength, float p_deadzone);
	virtual bool shortcut_match(const Ref<InputEvent> &p_event, bool p_exact_match = true);

	virtual bool is_action_type();

	virtual String as_text();

	InputEventKey();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

InputEventMouse
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class InputEventMouse : public InputEventWithModifiers {
	SFW_OBJECT(InputEventMouse, InputEventWithModifiers);

	int button_mask;

	Vector2 pos;
	Vector2 global_pos;

public:
	void set_button_mask(int p_mask);
	int get_button_mask();

	void set_position(const Vector2 &p_pos);
	Vector2 get_position();

	void set_global_position(const Vector2 &p_global_pos);
	Vector2 get_global_position();

	InputEventMouse();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

InputEventMouseButton
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class InputEventMouseButton : public InputEventMouse {
	SFW_OBJECT(InputEventMouseButton, InputEventMouse);

	float factor;
	int button_index;
	bool doubleclick; 

public:
	void set_factor(float p_factor);
	float get_factor();

	void set_button_index(int p_index);
	int get_button_index();

	void set_pressed(bool p_pressed);
	void set_canceled(bool p_canceled);

	void set_doubleclick(bool p_doubleclick);
	bool is_doubleclick();

	virtual Ref<InputEvent> xformed_by(const Transform2D &p_xform, const Vector2 &p_local_ofs = Vector2();
	virtual bool action_match(const Ref<InputEvent> &p_event, bool p_exact_match, bool *p_pressed, float *p_strength, float *p_raw_strength, float p_deadzone);
	virtual bool shortcut_match(const Ref<InputEvent> &p_event, bool p_exact_match = true);

	virtual bool is_action_type();
	virtual String as_text();

	InputEventMouseButton();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

InputEventMouseMotion
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class InputEventMouseMotion : public InputEventMouse {
	SFW_OBJECT(InputEventMouseMotion, InputEventMouse);

	Vector2 tilt;
	float pressure;
	Vector2 relative;
	Vector2 speed;
	bool pen_inverted;

public:
	void set_tilt(const Vector2 &p_tilt);
	Vector2 get_tilt();

	void set_pressure(float p_pressure);
	float get_pressure();

	void set_pen_inverted(bool p_inverted);
	bool get_pen_inverted();

	void set_relative(const Vector2 &p_relative);
	Vector2 get_relative();

	void set_speed(const Vector2 &p_speed);
	Vector2 get_speed();

	virtual Ref<InputEvent> xformed_by(const Transform2D &p_xform, const Vector2 &p_local_ofs = Vector2();
	virtual String as_text();

	virtual bool accumulate(const Ref<InputEvent> &p_event);

	InputEventMouseMotion();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

InputEventAction
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class InputEventAction : public InputEvent {
	SFW_OBJECT(InputEventAction, InputEvent);

	StringName action;
	float strength;

public:
	void set_action(const StringName &p_action);
	StringName get_action();

	void set_pressed(bool p_pressed);

	void set_strength(float p_strength);
	float get_strength();

	virtual bool is_action(const StringName &p_action);

	virtual bool action_match(const Ref<InputEvent> &p_event, bool p_exact_match, bool *p_pressed, float *p_strength, float *p_raw_strength, float p_deadzone);
	virtual bool shortcut_match(const Ref<InputEvent> &p_event, bool p_exact_match = true);

	virtual bool is_action_type();
	virtual String as_text();

	InputEventAction();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

InputEventShortCut
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class InputEventShortCut : public InputEvent {
	SFW_OBJECT(InputEventShortCut, InputEvent);

	Ref<ShortCut> shortcut;

public:
	void set_shortcut(Ref<ShortCut> p_shortcut);
	Ref<ShortCut> get_shortcut();

	virtual String as_text();
	virtual String to_string();

	InputEventShortCut();
	~InputEventShortCut();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ShortCut
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class ShortCut : public Resource {
	SFW_OBJECT(ShortCut, Resource);

public:
	void set_shortcut(const Ref<InputEvent> &p_shortcut);
	Ref<InputEvent> get_shortcut();
	bool is_shortcut(const Ref<InputEvent> &p_event);
	bool is_valid();

	String get_as_text();

	ShortCut();
	~ShortCut();

private:
	Ref<InputEvent> shortcut;
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

InputMap
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class InputMap : public Object {
	SFW_OBJECT(InputMap, Object);

public:
	
	static int ALL_DEVICES;

	struct Action {
		int id;
		float deadzone;
		List<Ref<InputEvent>> inputs;
	};

private:
	static InputMap *singleton;

	mutable RBMap<StringName, Action> input_map;

	List<Ref<InputEvent>>::Element *_find_event(Action &p_action, const Ref<InputEvent> &p_event, bool p_exact_match = false, bool *p_pressed = nullptr, float *p_strength = nullptr, float *p_raw_strength = nullptr);

	Array _get_action_list(const StringName &p_action);
	Array _get_actions();

public:
	static InputMap *get_singleton();

	bool has_action(const StringName &p_action);
	List<StringName> get_actions();
	void add_action(const StringName &p_action, float p_deadzone = 0.5);
	void erase_action(const StringName &p_action);

	float action_get_deadzone(const StringName &p_action);
	void action_set_deadzone(const StringName &p_action, float p_deadzone);
	void action_add_event(const StringName &p_action, const Ref<InputEvent> &p_event);
	bool action_has_event(const StringName &p_action, const Ref<InputEvent> &p_event);
	void action_erase_event(const StringName &p_action, const Ref<InputEvent> &p_event);
	void action_erase_events(const StringName &p_action);

	const List<Ref<InputEvent>> *get_action_list(const StringName &p_action);
	bool event_is_action(const Ref<InputEvent> &p_event, const StringName &p_action, bool p_exact_match = false);
	bool event_get_action_status(const Ref<InputEvent> &p_event, const StringName &p_action, bool p_exact_match = false, bool *p_pressed = nullptr, float *p_strength = nullptr, float *p_raw_strength = nullptr);

	const RBMap<StringName, Action> &get_action_map();
	void load_default();

	String suggest_actions(const StringName &p_action);

	InputMap();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Input
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class Input : public Object {
	SFW_OBJECT(Input, Object);

	_THREAD_SAFE_CLASS_

public:
	Signal joy_connection_changed_signal;

	enum MouseMode {
		MOUSE_MODE_VISIBLE,
		MOUSE_MODE_HIDDEN,
		MOUSE_MODE_CAPTURED
	};

#undef CursorShape
	enum CursorShape {
		CURSOR_ARROW,
		CURSOR_IBEAM,
		CURSOR_POINTING_HAND,
		CURSOR_CROSS,
		CURSOR_WAIT,
		CURSOR_BUSY,
		CURSOR_DRAG,
		CURSOR_CAN_DROP,
		CURSOR_FORBIDDEN,
		CURSOR_VSIZE,
		CURSOR_HSIZE,
		CURSOR_BDIAGSIZE,
		CURSOR_FDIAGSIZE,
		CURSOR_MOVE,
		CURSOR_VSPLIT,
		CURSOR_HSPLIT,
		CURSOR_HELP,
		CURSOR_MAX
	};

	enum HatMask {
		HAT_MASK_CENTER = 0,
		HAT_MASK_UP = 1,
		HAT_MASK_RIGHT = 2,
		HAT_MASK_DOWN = 4,
		HAT_MASK_LEFT = 8,
	};

	enum HatDir {
		HAT_UP,
		HAT_RIGHT,
		HAT_DOWN,
		HAT_LEFT,
		HAT_MAX,
	};

	enum {
		JOYPADS_MAX = 16,
	};

	static Input *get_singleton();

	void set_mouse_mode(MouseMode p_mode);
	MouseMode get_mouse_mode();

	virtual bool is_key_pressed(int p_scancode);
	virtual bool is_physical_key_pressed(int p_scancode);
	virtual bool is_mouse_button_pressed(int p_button);
	virtual bool is_action_pressed(const StringName &p_action, bool p_exact = false);
	virtual bool is_action_just_pressed(const StringName &p_action, bool p_exact = false);
	virtual bool is_action_just_released(const StringName &p_action, bool p_exact = false);
	virtual float get_action_strength(const StringName &p_action, bool p_exact = false);
	virtual float get_action_raw_strength(const StringName &p_action, bool p_exact = false);

	float get_axis(const StringName &p_negative_action, const StringName &p_positive_action);
	Vector2 get_vector(const StringName &p_negative_x, const StringName &p_positive_x, const StringName &p_negative_y, const StringName &p_positive_y, float p_deadzone = -1.0f);

	virtual Point2 get_mouse_position();
	virtual Point2 get_last_mouse_speed();
	virtual int get_mouse_button_mask();

	void set_mouse_position(const Point2 &p_posf);

	virtual void warp_mouse_position(const Vector2 &p_to);
	virtual Point2i warp_mouse_motion(const Ref<InputEventMouseMotion> &p_motion, const Rect2 &p_rect);

	virtual void action_press(const StringName &p_action, float p_strength = 1.f);
	virtual void action_release(const StringName &p_action);

	virtual CursorShape get_default_cursor_shape();
	virtual void set_default_cursor_shape(CursorShape p_shape);
	virtual CursorShape get_current_cursor_shape();
	virtual void set_custom_mouse_cursor(const Ref<Reference> &p_cursor, CursorShape p_shape = CURSOR_ARROW, const Vector2 &p_hotspot = Vector2();

	virtual void parse_input_event(const Ref<InputEvent> &p_event);

	virtual void flush_buffered_events();
	virtual bool is_using_input_buffering();
	virtual void set_use_input_buffering(bool p_enable);
	virtual bool is_using_accumulated_input();
	virtual void set_use_accumulated_input(bool p_enable);

	virtual void release_pressed_events();

	void set_main_loop(Application *p_main_loop);
	void iteration(real_t p_step);

	Input();

	void _setup_window_callbacks();

protected:
	static int glfw_to_sfw_code(int glfw_code);

	unsigned int get_mouse_button_state(unsigned int p_button, int p_type);
	static void get_key_modifier_state(int mods, Ref<InputEventWithModifiers> state);

	static void GLFWkeyfunCallback(GLFWwindow *window, int key, int scancode, int action, int mods);
	static void GLFWcharfunCallback(GLFWwindow *window, unsigned int codepoint);
	static void GLFWcharmodsfunCallback(GLFWwindow *window, unsigned int codepoint, int mods);
	static void GLFWmousebuttonfunCallback(GLFWwindow *window, int button, int action, int mods);
	static void GLFWcursorposfunCallback(GLFWwindow *window, double xpos, double ypos);
	static void GLFWcursorenterfunCallback(GLFWwindow *window, int entered);
	static void GLFWscrollfunCallback(GLFWwindow *window, double xoffset, double yoffset);
	static void GLFWdropfunCallback(GLFWwindow *window, int path_count, const char *paths[]);
	static void GLFWjoystickfunCallback(int jid, int event);
	static void GLFWwindowfocusfunCallback(GLFWwindow *window, int focused);

protected:

	struct SpeedTrack {
		uint64_t last_tick;
		Vector2 speed;
		Vector2 accum;
		float accum_t;
		float min_ref_frame;
		float max_ref_frame;

		void update(const Vector2 &p_delta_p);
		void reset();
		SpeedTrack();
	};

	struct Action {
		uint64_t pressed_idle_frame;
		uint64_t released_idle_frame;
		bool pressed;
		bool exact;
		float strength;
		float raw_strength;

		Action();
	};

	void _parse_input_event_impl(const Ref<InputEvent> &p_event, bool p_is_emulated);

	static String _hex_str(uint8_t p_byte);

	List<Ref<InputEvent>> buffered_events;
	bool use_input_buffering;
	bool use_accumulated_input;

	int mouse_button_mask;

	RBSet<int> physical_keys_pressed;
	RBSet<int> keys_pressed;

	Vector2 mouse_pos;

	Application *main_loop;
	bool legacy_just_pressed_behavior;

	Point2 last_mouse_pos;
	bool last_mouse_pos_valid;
	Point2i last_click_pos;
	uint64_t last_click_ms;
	int last_click_button_index;
	uint32_t last_button_state;

	int last_key_modifier_state;

	bool window_has_focus;

	RBMap<StringName, Action> action_state;

	SpeedTrack mouse_speed_track;

	CursorShape default_shape;

	static Input *singleton;
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Shader
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class Shader {
public:
	enum VertexAttributes {
		ATTRIBUTE_POSITION = 0,
		ATTRIBUTE_NORMAL,
		ATTRIBUTE_COLOR,
		ATTRIBUTE_UV,
	};

	bool bind();
	void unbind();

	void compile();
	void destroy();

	const char **get_vertex_shader_source();
	void set_vertex_shader_source(const char **source);

	const char **get_fragment_shader_source();
	void set_fragment_shader_source(const char **source);

	void print_shader_errors(const uint32_t p_program, const char *name);
	void print_program_errors(const uint32_t p_program);

	Shader();
	~Shader();

	uint32_t vertex_shader;
	uint32_t fragment_shader;
	uint32_t program;

	static Shader *current_shader;

protected:
	const char **vertex_shader_source;
	const char **fragment_shader_source;
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ShaderCache
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class ShaderCache {
public:
	static ShaderCache *get_singleton();

	Shader *get_shader(const int id);
	void add_shader(const int id, Shader *shader);

	ShaderCache();
	~ShaderCache();

protected:
	HashMap<int, Shader *> shaders;
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Material
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class Material : public Reference {
	SFW_OBJECT(Material, Reference);

public:
	void bind();

	virtual void unbind();
	virtual int get_material_id();
	virtual void bind_uniforms();
	virtual void setup_uniforms();
	virtual void setup_state();
	virtual const char **get_vertex_shader_source();
	virtual const char **get_fragment_shader_source();

	int32_t get_uniform(const char *name);

	Material();
	virtual ~Material();

protected:
	static Material *current_material;

	Shader *shader;

protected:
	void set_uniform(int32_t p_uniform, const Transform &p_transform);
	void set_uniform(int32_t p_uniform, const Transform2D &p_transform);
	void set_uniform(int32_t p_uniform, const Projection &p_matrix);
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ColorMaterial
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class ColorMaterial : public Material {
	SFW_OBJECT(ColorMaterial, Material);

public:
	int get_material_id();

	void bind_uniforms();
	void setup_uniforms();

	const char **get_vertex_shader_source();
	const char **get_fragment_shader_source();

	ColorMaterial();

	int32_t projection_matrix_location;
	int32_t camera_matrix_location;
	int32_t model_view_matrix_location;
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ColorMaterial2D
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class ColorMaterial2D : public Material {
	SFW_OBJECT(ColorMaterial2D, Material);

public:
	int get_material_id();

	void bind_uniforms();
	void setup_uniforms();
	void unbind();
	void setup_state();

	const char **get_vertex_shader_source();
	const char **get_fragment_shader_source();

	ColorMaterial2D();

	int32_t projection_matrix_location;
	int32_t model_view_matrix_location;
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

TextureMaterial2D
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class TextureMaterial2D : public Material {
	SFW_OBJECT(TextureMaterial2D, Material);

public:
	int get_material_id();

	void bind_uniforms();
	void setup_uniforms();
	void unbind();
	void setup_state();

	const char **get_vertex_shader_source();
	const char **get_fragment_shader_source();

	TextureMaterial2D();
	
	int32_t projection_matrix_location;
	int32_t model_view_matrix_location;

	int32_t texture_location;

	Ref<Texture> texture;
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

TextureMaterial
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class TextureMaterial : public Material {
	SFW_OBJECT(TextureMaterial, Material);

public:
	int get_material_id();

	void bind_uniforms();
	void setup_uniforms();
	void unbind();
	void setup_state();

	const char **get_vertex_shader_source();
	const char **get_fragment_shader_source();

	TextureMaterial();

	int32_t projection_matrix_location;
	int32_t camera_matrix_location;
	int32_t model_view_matrix_location;

	int32_t texture_location;

	Ref<Texture> texture;
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ColoredMaterial
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class ColoredMaterial : public Material {
public:
	int get_material_id();

	void bind_uniforms();
	void setup_uniforms();

	const char **get_vertex_shader_source();
	const char **get_fragment_shader_source();

	ColoredMaterial();

	int32_t projection_matrix_location;
	int32_t model_view_matrix_location;

	int32_t tri_color_uniform_location;
	Color color;
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

FontMaterial
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class FontMaterial : public Material {
	SFW_OBJECT(FontMaterial, Material);

public:
	int get_material_id();

	void bind_uniforms();
	void setup_uniforms();
	void unbind();
	void setup_state();

	const char **get_vertex_shader_source();
	const char **get_fragment_shader_source();

	FontMaterial();

	int32_t projection_matrix_location;
	int32_t model_view_matrix_location;

	int32_t texture_location;

	Ref<Texture> texture;
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

TransparentTextureMaterial
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class TransparentTextureMaterial : public Material {
	SFW_OBJECT(TransparentTextureMaterial, Material);

public:
	int get_material_id();

	void bind_uniforms();
	void setup_uniforms();
	void unbind();
	void setup_state();

	const char **get_vertex_shader_source();
	const char **get_fragment_shader_source();

	TransparentTextureMaterial();

	int32_t projection_matrix_location;
	int32_t model_view_matrix_location;

	int32_t texture_location;

	Ref<Texture> texture;
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Font
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class Font : public Resource {
	SFW_OBJECT(Font, Resource);

public:
	
	enum FONT_FLAGS {
		
		FONT_512 = 0x0,
		FONT_1024 = 0x1,
		FONT_2048 = 0x2,
		FONT_4096 = 0x4,

		FONT_NO_OVERSAMPLE = 0x0,
		FONT_OVERSAMPLE_X = 0x08,
		FONT_OVERSAMPLE_Y = 0x10,

		FONT_ASCII = 0x800, 
		FONT_AR = 0x001000, 
		FONT_ZH = 0x002000, 
		FONT_EL = 0x004000, 
		FONT_EM = 0x008000, 
		FONT_EU = 0x010000, 
		FONT_HE = 0x020000, 
		FONT_JP = 0x040000, 
		FONT_KR = 0x080000, 
		FONT_RU = 0x100000, 
		FONT_TH = 0x200000, 
		FONT_VI = 0x400000, 
		FONT_CJK = FONT_ZH | FONT_JP | FONT_KR,

	};

	struct FontMetrics {
		float ascent; 
		float descent; 
		float linegap; 
		float linedist; 
	};

	void load_default(const float size, const uint32_t flags = 0);

	float get_scale();
	void set_scale(const float p_scale);

	void font_face(const char *filename_ttf, float font_size, uint32_t flags);
	void font_face_from_mem(const void *ttf_buffer, uint32_t ttf_len, float font_size, uint32_t flags);

	Vector2 generate_mesh(const String &p_text, Ref<Mesh> &p_into, const Color &p_color = Color(1, 1, 1, 1);
	Vector2 get_string_size(const String &p_text);
	FontMetrics font_metrics();

	int get_atlas_width();
	int get_atlas_height();

	Ref<Image> get_image();
	Ref<Texture> get_texture();

	void unload();

	Font();
	~Font();

protected:
	
	uint32_t _num_glyphs;
	uint32_t *_cp2iter;
	uint32_t *_iter2cp;
	uint32_t _begin; 

	bool _initialized;

	int _height; 
	int _width; 
	float _font_size; 
	float _factor; 
	float _scale;

	float _ascent; 
	float _descent; 
	float _linegap; 
	float _linedist; 

	Ref<Image> _image;
	Ref<Texture> _texture;

	struct TextureOffset {
		float x0;
		float y0;
		float x1;
		float y1;

		float x0_orig;
		float y0_orig;
		float x1_orig;
		float y1_orig;

		float xoff;
		float xoff2;
		float xadvance;
		float yoff;
		float yoff2;
	};

	Vector<TextureOffset> _texture_offsets;
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Scene
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class Scene : public Reference {
	SFW_OBJECT(Scene, Reference);

public:
	virtual void input_event(const Ref<InputEvent> &event);
	virtual void update(float delta);
	virtual void render();

	Scene();
	virtual ~Scene();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

AppWindow
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class AppWindow {
public:
	enum WINDOW_FLAGS {
		WINDOW_MSAA2 = 0x02,
		WINDOW_MSAA4 = 0x04,
		WINDOW_MSAA8 = 0x08,

		WINDOW_SQUARE = 0x20,
		WINDOW_PORTRAIT = 0x40,
		WINDOW_LANDSCAPE = 0x80,
		WINDOW_ASPECT = 0x100, 
		WINDOW_FIXED = 0x200, 
		WINDOW_TRANSPARENT = 0x400,
		WINDOW_BORDERLESS = 0x800,

		WINDOW_VSYNC = 0,
		WINDOW_VSYNC_ADAPTIVE = 0x1000,
		WINDOW_VSYNC_DISABLED = 0x2000,
	};

	bool create(float scale, unsigned int flags);
	bool create_from_handle(void *handle, float scale, unsigned int flags);

	int frame_begin();
	void frame_end();
	void frame_swap();
	int swap();

	void loop(void (*function);
	void loop_exit();

	void set_title(const char *title);
	void set_color(unsigned color);
	Vector2 get_canvas();
	void *get_handle();
	char *get_stats();

	uint64_t frame();
	int get_width();
	int get_height();
	double get_time();
	double get_delta();

	void set_focus();
	int has_focus();
	
	void set_fullscreen(int enabled);
	int has_fullscreen();

	enum MouseMode {
		MOUSE_MODE_VISIBLE, 
		MOUSE_MODE_HIDDEN, 
		MOUSE_MODE_CAPTURED 
	};

	void set_mouse_mode(MouseMode p_mode);
	MouseMode get_mouse_mode();

	void set_pause(int paused);
	int has_pause();

	void set_visible(int visible);
	int has_visible();

	void set_maximize(int enabled);
	int has_maximize();

	void set_transparent(int enabled);
	int has_transparent();

	void set_icon(const char *file_icon);
	int has_icon();

	double get_aspect();
	void aspect_lock(unsigned numer, unsigned denom);
	void aspect_unlock();

	double get_fps();
	double get_fps_target();

	void fps_lock(float fps);
	void fps_unlock();

	void shutdown();

	Vector2 dpi();

	enum CURSOR_SHAPES {
		CURSOR_NONE,
		CURSOR_HW_ARROW, 
		CURSOR_HW_IBEAM, 
		CURSOR_HW_HDRAG, 
		CURSOR_HW_VDRAG, 
		CURSOR_HW_HAND, 
		CURSOR_HW_CROSS, 
		CURSOR_SW_AUTO, 
	};

	void set_cursor_shape(unsigned shape);

	const char *get_clipboard();
	void set_clipboard(const char *text);

	static AppWindow *get_singleton();

	AppWindow();
	~AppWindow();

protected:
	static void glfw_quit();
	static void glfw_init();
	static void glfw_error_callback(int error, const char *description);
	static void drop_callback(GLFWwindow *window, int count, const char **paths);
	static void window_hints(unsigned flags);
	GLFWmonitor *find_monitor(int wx, int wy);
	void resize();
	static void loop_wrapper(void *loopArg);
	void glNewFrame();
	double get_scale();
	void create_default_cursors();

	static AppWindow *_singleton;

	double boot_time;

	GLFWwindow *_window;
	int w;
	int h;
	int xpos;
	int ypos;
	int paused;
	int fullscreen;
	int xprev;
	int yprev;
	int wprev;
	int hprev;
	uint64_t frame_count;
	double t;
	double dt;
	double fps;
	double hz;
	char title[128];
	int locked_aspect_ratio;
	Color winbgcolor;
	int _has_icon;

	int _cursorshape = 1;

	void (*render_callback);
	Vector2 last_canvas_size;

	int width;
	int height;
	bool keep_running;
	unsigned int _window_flags;

	bool _fullscreen;
	bool _transparent;
	bool _vsync;
	bool _vsync_adaptive;

	bool _cursors_initialized;
	GLFWcursor *cursors[7];
	unsigned int cursor_enums[7];
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Application
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class Application : public Object {
	SFW_OBJECT(Application, Object);

public:
	enum {
		NOTIFICATION_WM_MOUSE_ENTER = 1002,
		NOTIFICATION_WM_MOUSE_EXIT = 1003,
		NOTIFICATION_WM_FOCUS_IN = 1004,
		NOTIFICATION_WM_FOCUS_OUT = 1005,
		NOTIFICATION_WM_QUIT_REQUEST = 1006,
		NOTIFICATION_WM_GO_BACK_REQUEST = 1007,
		NOTIFICATION_WM_UNFOCUS_REQUEST = 1008,

		NOTIFICATION_APP_RESUMED = 1014,
		NOTIFICATION_APP_PAUSED = 1015,
	};

	bool running;
	int target_fps;

	virtual void input_event(const Ref<InputEvent> &event);
	virtual void update(float delta);
	virtual void render();

	uint64_t get_idle_frames();

	void main_loop();

	void main_loop_static();

	Application();
	virtual ~Application();

	Ref<Scene> scene;

	static Application *get_singleton();

	real_t frame_delta;

protected:
	virtual void _init_window();

	static Application *_instance;

	uint64_t _idle_frames;

	real_t _time_scale;
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Renderer
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class Renderer : public Object {
	SFW_OBJECT(Renderer, Object);

public:
	bool get_depth_buffer_enable();
	void set_depth_buffer_enable(const bool p_depth_buffer);

	void draw_point(const Vector2 &p_position, const Color &p_color = Color(1, 1, 1);
	void draw_line(const Vector2 &p_from, const Vector2 &p_to, const Color &p_color = Color(1, 1, 1);
	void draw_line_rect(const Rect2 &p_rect, const Color &p_color = Color(1, 1, 1);
	void draw_rect(const Rect2 &p_rect, const Color &p_color = Color(1, 1, 1);

	void draw_texture(const Ref<Texture> &p_texture, const Rect2 &p_dst_rect, const Color &p_modulate = Color(1, 1, 1);
	void draw_texture_clipped(const Ref<Texture> &p_texture, const Rect2 &p_src_rect, const Rect2 &p_dst_rect, const Color &p_modulate = Color(1, 1, 1);
	void draw_texture_tr(const Transform2D &p_transform_2d, const Ref<Texture> &p_texture, const Rect2 &p_dst_rect, const Color &p_modulate = Color(1, 1, 1);
	void draw_texture_clipped_tr(const Transform2D &p_transform_2d, const Ref<Texture> &p_texture, const Rect2 &p_src_rect, const Rect2 &p_dst_rect, const Color &p_modulate = Color(1, 1, 1);

	void draw_mesh_2d(const Ref<Mesh> &p_mesh, const Ref<Texture> &p_texture, const Vector2 &p_position);
	void draw_mesh_2d_tr(const Ref<Mesh> &p_mesh, const Ref<Texture> &p_texture, const Transform2D &p_transform_2d);
	void draw_mesh_2d_mat(const Ref<Mesh> &p_mesh, const Ref<Material> &p_material, const Vector2 &p_position);
	void draw_mesh_2d_mat_tr(const Ref<Mesh> &p_mesh, const Ref<Material> &p_material, const Transform2D &p_transform_2d);

	void draw_text_2d(const String &p_text, const Ref<Font> &p_font, const Vector2 &p_position, const Color &p_color = Color(1, 1, 1);
	void draw_text_2d_tf(const String &p_text, const Ref<Font> &p_font, const Transform2D &p_transform_2d, const Color &p_color = Color(1, 1, 1);
	void draw_text_2d_tf_material(const String &p_text, const Ref<Font> &p_font, const Ref<Material> &p_material, const Transform2D &p_transform_2d, const Color &p_color = Color(1, 1, 1);

	void draw_mesh_3d(const Ref<Mesh> &p_mesh, const Ref<Material> &p_material, const Transform &p_transform);

	Transform2D camera_2d_get_current_model_view_matrix();
	void camera_2d_push_model_view_matrix(const Transform2D &p_transform_2d);
	void camera_2d_pop_model_view_matrix();
	int get_camera_2d_model_view_matrix_stack_size();
	void camera_2d_reset();

	void camera_3d_reset();

	void clear_screen(const Color &p_color);

	Vector2i get_window_size();
	float get_window_aspect();

	static void initialize();
	static void destroy();

	Renderer();
	~Renderer();

	static Renderer *get_singleton();

private:
	static Renderer *_singleton;

	bool _depth_buffer;

	Ref<Mesh> _2d_mesh;
	Ref<Mesh> _3d_mesh;
	Ref<Mesh> _font_mesh;

	Ref<TextureMaterial2D> _texture_material_2d;
	Ref<FontMaterial> _font_material;
	Ref<ColorMaterial2D> _color_material_2d;

	Vector<Transform2D> camera_2d_model_view_matrix_stack;
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Object2D
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class Object2D : public Object {
    SFW_OBJECT(Object2D, Object);

public:
    Object2D();
    virtual ~Object2D();

    Transform2D transform;
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Object3D
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class Object3D : public Object {
	SFW_OBJECT(Object3D, Object);

public:
	Object3D();
	virtual ~Object3D();

	Transform transform;
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Camera2D
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class Camera2D : public Object2D {
	SFW_OBJECT(Camera2D, Object2D);

public:
	Transform2D get_model_view_matrix();
	void set_model_view_matrix(const Transform2D &p_value);

	Transform get_projection_matrix();
	void set_projection_matrix(const Transform &p_value);

	virtual void bind();

	void make_current();

	Camera2D();
	virtual ~Camera2D();

	Vector2 size;

	static Camera2D *current_camera;

protected:
	Transform2D _model_view_matrix;
	Transform _projection_matrix;
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

MeshInstance2D
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class MeshInstance2D : public Object2D {
	SFW_OBJECT(MeshInstance2D, Object2D);

public:
	void render();

	MeshInstance2D();
	~MeshInstance2D();

	Ref<Material> material;
	Ref<Mesh> mesh;

	Transform2D transform;

	Vector<MeshInstance2D *> children;
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Sprite
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class Sprite : public Object2D {
public:
    void render();
    void update_mesh();

    Sprite();
    ~Sprite();

    Transform2D transform;

    MeshInstance2D *mesh_instance;

    float width;
    float height;

    float region_x;
    float region_y;
    float region_width;
    float region_height;
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Text2D
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class Text2D : public Object2D {
	SFW_OBJECT(Text2D, Object2D);

public:
	Color get_text_color();
	void set_text_color(const Color &p_color);

	String get_text();
	void set_text(const String &p_text);

	Ref<Font> get_font();
	void set_font(const Ref<Font> &p_font);

	Vector2 get_text_size();

	void update();
	void render();

	Text2D();
	~Text2D();

protected:
	Ref<Font> _font;
	Ref<FontMaterial> _material;
	Ref<Mesh> _mesh;
	String _text;
	Color _text_color;
	Vector2 _text_size;
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

TileMap
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class TileMap : public Object2D {
	SFW_OBJECT(TileMap, Object2D);

public:
	void build_mesh();
	void allocate_data();
	void add_rect(const int x, const int y, const float uv_x, const float uv_y, const float uv_size_x, const float uv_size_y);

	uint8_t get_data(const int x, const int y);
	void set_data(const int x, const int y, const uint8_t value);

	void render();

	TileMap();
	~TileMap();

	uint8_t *data;
	int size_x;
	int size_y;

	int atlas_size_x;
	int atlas_size_y;

	Ref<Mesh> mesh;
	Ref<Material> material;
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Camera3D
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class Camera3D : public Object3D {
	SFW_OBJECT(Camera3D, Object3D);

public:
	Transform get_camera_transform();
	void set_camera_transform(const Transform &p_value);

	Transform get_model_view_matrix();
	void set_model_view_matrix(const Transform &p_value);

	Projection get_projection_matrix();
	void set_projection_matrix(const Projection &p_value);

	virtual void bind();

	void make_current();

	Camera3D();
	virtual ~Camera3D();

	float size;
	float screen_aspect_ratio; 
	float znear;
	float zfar;
	bool vaspect;

	static Camera3D *current_camera;

protected:
	Transform _camera_transform;
	Transform _model_view_matrix;
	Projection _projection_matrix;
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

OrthographicCamera
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class OrthographicCamera : public Camera3D {
public:
	void bind();

	OrthographicCamera();
	~OrthographicCamera();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

PerspectiveCamera
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class PerspectiveCamera : public Camera3D {
public:
	float fov;

	void bind();

	PerspectiveCamera();
	~PerspectiveCamera();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

FrustumCamera
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class FrustumCamera : public Camera3D {
public:
	float offset;

	void bind();

	FrustumCamera();
	~FrustumCamera();
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

MeshInstance3D
----------------------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
class MeshInstance3D : public Object3D {
	SFW_OBJECT(MeshInstance3D, Object3D);

public:
	void render();

	MeshInstance3D();
	~MeshInstance3D();

	Ref<Material> material;
	Ref<Mesh> mesh;

	Vector<MeshInstance3D *> children;
};


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Modules
----------------------------------------------------------------------------------------

The CA library contains the APIs for applications to allocate and exchange resources.


!!! Attention Attention
    Always read all of the documentation.

[CA APIs](#CA)
: List of APIs to manage external processes.
 
CA Buffer List APIs
: Methods to process buffer resources separate from computation.
 
CA Data Structures
: Specifies the data structures used for complex cases.


## Handles

`CA::OpenHandle(const std::string&)`
: Open a reference handle.
 
`CA::ReadMetaData(const Handle&)`
: Metadata about the event.

`CA::CloseHandle(const Handle&)`
: Free all handle resources, recursively.


CA
====================================================================================

!!! Warning Warning
    The API content represents the set of APIs you can use directly. Some APIs
    are not documented and we advise you do not use them directly. Using undocumented
    APIs can lead to incompatibility when upgrading to later releases.


These examples assume that your directory structure is:

**********************************************************
*
*   📂 ca1
*   |
*   +-- 📄 bar.txt
*   |
*   +-- 📂 foo
*   |   |
*   |   ⋮
*   |   
*   +-- 📂 xsource
*   |   |
*   |   +-- 📂 data
*   |   |   |
*   |   |   +-- 📄 manifest.json
*   |   |   |
*   |   ⋮   ⋮
*   |
*   ⋮
**********************************************************
[Directory structure.]


Table
------------------------------------------------------------------


Screen     | Factor      | Used      | Efficiency
----------:|------------:|----------:|---------:
1366x768   |  3x         | 1152x672  | 74%
1440x900   |  3x         | 1152x672  | 60%
*1600x900* |  *4x*       | 1536x896  | *96%*
1680x1050  |  4x         | 1536x896  | 78%
1920x1080  |  4x         | 1536x896  | 66%
*1920x1200*|  *5x*       | 1920x1120 | *93%*
[A Table]


More Info 
------------------------------------------------------------------

******************************************************************
*                                       ^ y
*                                       | 
*     .---------.                  .----|----.
*     |         |                  |    |    |
*     |    *-------> x             |    *--------> x
*     |    |    |                  |         |
*     '----|----'                  '---------'
*          |
*          v y
******************************************************************
[Figure 1: Coordinate Example]


                       -----

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GLSL
vec3 sphNormal(in vec3 pos, in vec4 sph) {
   return normalize(pos-sph.xyz);
}

vec3 camera(vec2 U, vec2 r, vec3 ro, vec3 la, float fl) {
   vec2 uv = (U - r*.5)/r.y;
   vec3 fwd = normalize(la-ro),
        rgt = normalize(vec3(fwd.z, 0., -fwd.x));
   return normalize(fwd + fl*uv.x*rgt + fl*uv.y*cross(fwd, rgt));
}

float vMap(vec3 p) {
   float hit = 0.0;
   vec2 h2 = hash22(floor(p.xz*0.25));
   if (p.z > 0.0) {
       if (p.y < -10.0 && h2.x > 0.5) hit=1.0;
       if (p.y > 10.0 && h2.y > 0.5) hit=1.0;
   }
   return hit;   
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Code listing]

<script>markdeepOptions = {tocStyle:'long', definitionStyle:'long', linkAPIDefinitions: true};</script>
<link rel="stylesheet" href="slate.css">
<!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="markdeep.min.js"></script><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibil